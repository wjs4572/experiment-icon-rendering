<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Performance Summary Dashboard - Icon Rendering Tests</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js for visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Internationalization System -->
    <script src="js/i18n.js"></script>
</head>
<body class="min-h-screen bg-gray-50">
    <div class="container mx-auto px-8 py-12">
        <!-- Language Selector -->
        <div class="text-right mb-4">
            <select id="languageSelector" class="px-3 py-2 text-sm border border-gray-300 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="en">English</option>
                <option value="en-us">English (United States)</option>
                <option value="en-gb">English (United Kingdom)</option>
                <option value="es">Espa√±ol</option>
                <option value="fr">Fran√ßais</option>
                <option value="de">Deutsch</option>
                <option value="ja">Êó•Êú¨Ë™û</option>
                <option value="zh">‰∏≠Êñá</option>
                <option value="zh-tw">‰∏≠Êñá (ÁπÅÈ´î)</option>
                <option value="pt">Portugu√™s</option>
                <option value="pt-br">Portugu√™s (Brasil)</option>
                <option value="pt-pt">Portugu√™s (Portugal)</option>
            </select>
        </div>
        
        <!-- Header -->
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold text-gray-800 mb-4" data-i18n="summary.title">Performance Summary Dashboard</h1>
            <p class="text-xl text-gray-600 max-w-3xl mx-auto" data-i18n="summary.subtitle">
                Comprehensive analysis and comparison of icon rendering performance across all tested formats.
            </p>
            
            <!-- Browser-specific notice -->
            <div class="mt-4 p-3 bg-yellow-50 border border-yellow-300 rounded-lg text-sm max-w-4xl mx-auto">
                <div class="flex items-center justify-center">
                    <span class="mr-2 text-yellow-600">üåê</span>
                    <div>
                        <strong class="text-yellow-800" data-i18n="summary.browser_notice">Browser-Specific Results:</strong>
                        <span class="text-yellow-700 ml-1" data-i18n="summary.browser_notice_desc">All performance data shown is specific to the browser environment where tests were executed</span>
                    </div>
                </div>
            </div>
            
            <div class="mt-6 space-x-4">
                <a href="index.html" class="inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors" data-i18n="summary.back_to_tests">
                    ‚Üê Back to Test Suite
                </a>
                <a href="past-results.html" class="inline-flex items-center px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors" data-i18n="summary.view_past_results">
                    üìä View Past Results
                </a>
            </div>
        </header>

        <!-- Data Export & Controls -->
        <div class="flex justify-between items-center mb-8">
            <div class="flex space-x-4 flex-wrap gap-2">
                <button id="exportCsv" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors" data-i18n="summary.export_csv">
                    Export CSV
                </button>
                <button id="exportJson" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors" data-i18n="summary.export_json">
                    Export JSON
                </button>
                <button id="clearData" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors" data-i18n="summary.clear_data">
                    Clear All Data
                </button>
            </div>
            <div class="text-sm text-gray-500">
                <span data-i18n="summary.last_updated">Last updated:</span> <span id="lastUpdated" data-i18n="summary.never">Never</span>
            </div>
        </div>

        <!-- Summary Cards -->
        <div id="summaryCards" class="grid md:grid-cols-2 lg:grid-cols-3 gap-6 mb-12">
            <!-- Cards will be populated dynamically -->
        </div>

        <!-- Error/No Data Message -->
        <div id="noDataMessage" class="hidden bg-yellow-50 border border-yellow-200 p-6 rounded-lg text-center">
            <h3 class="text-lg font-semibold text-yellow-800 mb-2" data-i18n="summary.no_data_title">No Test Data Available</h3>
            <p class="text-yellow-700 mb-4" data-i18n="summary.no_data_desc">
                No performance test results found. Run some tests or import previous results from the Past Results Archive.
            </p>
            <div class="space-x-4">
                <a href="index.html" class="inline-block px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 transition-colors" data-i18n="summary.run_tests">
                    Go Back to Run Tests
                </a>
                <a href="past-results.html" class="inline-block px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" data-i18n="summary.view_past_results">
                    üìä View Past Results
                </a>
            </div>
        </div>

        <!-- Filter Controls -->
        <div id="summaryFilterSection" class="bg-white p-6 rounded-xl shadow-lg mb-8 hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-semibold text-gray-800" data-i18n="summary.filter_title">Filter Results</h2>
                <div class="flex items-center gap-3">
                    <span id="summaryFilterCount" class="text-sm text-gray-500"></span>
                    <button id="summaryClearFilters" class="px-3 py-1.5 text-sm bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors hidden" data-i18n="past.clear_filters">
                        Clear Filters
                    </button>
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-6 gap-4">
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1" for="summaryFilterTestType" data-i18n="past.filter.test_type">Test Type:</label>
                    <select id="summaryFilterTestType" class="w-full p-1.5 border rounded text-sm">
                        <option value="" data-i18n="past.filter.all_types">All Types</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1" for="summaryFilterDate" data-i18n="past.filter.date_range">Date Range:</label>
                    <select id="summaryFilterDate" class="w-full p-1.5 border rounded text-sm">
                        <option value="" data-i18n="past.filter.all_time">All Time</option>
                        <option value="today" data-i18n="past.filter.today">Today</option>
                        <option value="week" data-i18n="past.filter.week">Past Week</option>
                        <option value="month" data-i18n="past.filter.month">Past Month</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1" for="summaryFilterSignificance" data-i18n="past.filter.significance">Significance:</label>
                    <select id="summaryFilterSignificance" class="w-full p-1.5 border rounded text-sm">
                        <option value="" data-i18n="past.filter.all_results">All Results</option>
                        <option value="significant" data-i18n="past.filter.significant">Significant Only</option>
                        <option value="not-significant" data-i18n="past.filter.not_significant">Not Significant Only</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1" for="summaryFilterOriginalSource" data-i18n="past.filter.original_source">Original Source:</label>
                    <select id="summaryFilterOriginalSource" class="w-full p-1.5 border rounded text-sm">
                        <option value="" data-i18n="past.filter.all_sources">All Sources</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1" for="summaryFilterInputSource" data-i18n="past.filter.input_source">Input Source:</label>
                    <select id="summaryFilterInputSource" class="w-full p-1.5 border rounded text-sm">
                        <option value="" data-i18n="past.filter.all_inputs">All Inputs</option>
                        <option value="Current Data" data-i18n="past.filter.current_data">Current Data (Live Tests)</option>
                        <option value="file" data-i18n="past.filter.imported_file">Imported File</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1" for="summaryFilterFileName" data-i18n="past.filter.file_name">File Name:</label>
                    <select id="summaryFilterFileName" class="w-full p-1.5 border rounded text-sm">
                        <option value="" data-i18n="past.filter.all_files">All Files</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Performance Comparison Chart -->
        <div id="comparisonSection" class="hidden">
            <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-6" data-i18n="summary.chart_title">Cross-Format Performance Comparison</h2>
                <div class="h-96">
                    <canvas id="performanceChart"></canvas>
                </div>
            </div>

            <!-- Detailed Results Table -->
            <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-6" data-i18n="summary.results_title">Detailed Test Results</h2>
                <div class="overflow-x-auto">
                    <table id="resultsTable" class="w-full text-sm">
                        <thead>
                            <tr class="bg-gray-50 border-b">
                                <th class="p-3 text-left" data-i18n="summary.table.format">Format</th>
                                <th class="p-3 text-center" data-i18n="summary.table.date">Test Date</th>
                                <th class="p-3 text-center" data-i18n="summary.table.iterations">Iterations</th>
                                <th class="p-3 text-center" data-i18n="summary.table.best">Best Performance</th>
                                <th class="p-3 text-center" data-i18n="summary.table.average">Avg ¬± CI (ms)</th>
                                <th class="p-3 text-center" data-i18n="summary.table.duration">Test Duration</th>
                                <th class="p-3 text-center" data-i18n="summary.table.source_page">Source Page</th>
                                <th class="p-3 text-center" data-i18n="summary.table.data_source">Data Source</th>
                                <th class="p-3 text-center" data-i18n="summary.table.imported">Imported</th>
                                <th class="p-3 text-center" data-i18n="summary.table.status">Status</th>
                            </tr>
                        </thead>
                        <tbody id="resultsTableBody">
                            <!-- Table rows will be populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Statistical Analysis -->
            <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-6" data-i18n="summary.stats_title">Statistical Analysis Overview</h2>
                <div id="statisticalAnalysis" class="space-y-4">
                    <!-- Statistical analysis will be populated dynamically -->
                </div>
            </div>

            <!-- Test Environment Information -->
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-6" data-i18n="summary.environment_title">Test Environment</h2>
                <div id="testEnvironment" class="grid md:grid-cols-2 gap-4 text-sm">
                    <!-- Environment info will be populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <script>
        class SummaryDashboard {
            constructor() {
                this.testFormats = ['css', 'svg', 'png', 'gif', 'jpeg', 'webp', 'avif'];
                this.results = {};
                this.archiveHistory = [];
                this.chartInstance = null;
                this.loadArchiveHistory();
                this.loadResults();
                this.setupEventListeners();
                this.populateFilterDropdowns();
                this.restoreFilterState();
                this.render();
            }

            t(key) {
                return window.i18n ? window.i18n.translate(key) : key;
            }

            getLocale() {
                return window.i18n?.currentLanguage || navigator.language || 'en';
            }

            formatDate(dateStr) {
                if (!dateStr) return 'N/A';
                const d = new Date(dateStr);
                return isNaN(d) ? 'N/A' : d.toLocaleString(this.getLocale());
            }

            formatNumber(num) {
                return typeof num === 'number' ? num.toLocaleString(this.getLocale()) : num;
            }

            inferFormatFromResults(results) {
                if (!results || typeof results !== 'object') return null;
                const keys = Object.keys(results);
                if (keys.length === 0) return null;
                const firstKey = keys[0].toLowerCase();
                if (firstKey.includes('css'))   return 'css';
                if (firstKey.includes('svg'))   return 'svg';
                if (firstKey.includes('png'))   return 'png';
                if (firstKey.includes('gif'))   return 'gif';
                if (firstKey.includes('jpeg'))  return 'jpeg';
                if (firstKey.includes('webp'))  return 'webp';
                if (firstKey.includes('avif'))  return 'avif';
                return null;
            }

            loadArchiveHistory() {
                try {
                    const raw = localStorage.getItem('iconTestHistory');
                    this.archiveHistory = raw ? JSON.parse(raw) : [];
                } catch (e) {
                    console.error('Error loading archive history:', e);
                    this.archiveHistory = [];
                }
            }

            getFilterState() {
                return {
                    testType: document.getElementById('summaryFilterTestType')?.value || '',
                    dateRange: document.getElementById('summaryFilterDate')?.value || '',
                    significance: document.getElementById('summaryFilterSignificance')?.value || '',
                    originalSource: document.getElementById('summaryFilterOriginalSource')?.value || '',
                    inputSource: document.getElementById('summaryFilterInputSource')?.value || '',
                    fileName: document.getElementById('summaryFilterFileName')?.value || ''
                };
            }

            hasActiveFilters() {
                const f = this.getFilterState();
                return !!(f.testType || f.dateRange || f.significance || f.originalSource || f.inputSource || f.fileName);
            }

            filterArchiveEntries(entries) {
                const f = this.getFilterState();
                if (!f.testType && !f.dateRange && !f.significance && !f.originalSource && !f.inputSource && !f.fileName) {
                    return entries;
                }
                let filtered = [...entries];
                if (f.testType) {
                    filtered = filtered.filter(r => r.testConfiguration?.testType === f.testType);
                }
                if (f.dateRange) {
                    const now = new Date();
                    let cutoff;
                    if (f.dateRange === 'today') cutoff = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    else if (f.dateRange === 'week') cutoff = new Date(now.getTime() - 7*24*60*60*1000);
                    else if (f.dateRange === 'month') cutoff = new Date(now.getTime() - 30*24*60*60*1000);
                    if (cutoff) filtered = filtered.filter(r => new Date(r.timestamp) >= cutoff);
                }
                if (f.significance === 'significant') {
                    filtered = filtered.filter(r => r.summary?.significantDifferences > 0);
                } else if (f.significance === 'not-significant') {
                    filtered = filtered.filter(r => !r.summary?.significantDifferences || r.summary.significantDifferences === 0);
                }
                if (f.originalSource) {
                    filtered = filtered.filter(r => {
                        const src = r.sourceInfo?.originalSource || (this.inferFormatFromResults(r.results) + '.html');
                        return src === f.originalSource;
                    });
                }
                if (f.inputSource === 'Current Data') {
                    filtered = filtered.filter(r => !r.sourceInfo?.fileName || r.sourceInfo.fileName === 'Current Data');
                } else if (f.inputSource === 'file') {
                    filtered = filtered.filter(r => r.sourceInfo?.fileName && r.sourceInfo.fileName !== 'Current Data');
                }
                if (f.fileName) {
                    filtered = filtered.filter(r => r.sourceInfo?.fileName === f.fileName);
                }
                return filtered;
            }

            loadResults() {
                this.results = {};
                let hasData = false;
                const f = this.getFilterState();
                const inputFilter = f.inputSource;
                const fileFilter = f.fileName;

                // 1. Load per-format keys (from live test sessions) ‚Äî skip if filtering to imported only
                if (inputFilter !== 'file' && !fileFilter) {
                    this.testFormats.forEach(format => {
                        try {
                            const data = localStorage.getItem(`iconTestResults_${format}`);
                            if (data) {
                                const parsed = JSON.parse(data);
                                // Apply source filter to live data
                                if (f.originalSource && f.originalSource !== `${format}.html`) return;
                                parsed._sourceInfo = {
                                    originalSource: `${format}.html`,
                                    fileName: 'Current Data',
                                    importedAt: null
                                };
                                parsed._dataOrigin = 'live';
                                this.results[format] = parsed;
                                hasData = true;
                            }
                        } catch (error) {
                            console.error(`Error loading ${format} results:`, error);
                        }
                    });
                }

                // 2. Load from iconTestHistory archive ‚Äî apply filters, then pick latest per format
                try {
                    const filteredHistory = this.filterArchiveEntries(this.archiveHistory);
                    const latestByFormat = {};
                    filteredHistory.forEach(entry => {
                        const format = this.inferFormatFromResults(entry.results);
                        if (!format) return;
                        if (!latestByFormat[format] || new Date(entry.timestamp) > new Date(latestByFormat[format].timestamp)) {
                            latestByFormat[format] = entry;
                        }
                    });

                    Object.entries(latestByFormat).forEach(([format, entry]) => {
                        const converted = this.convertHistoryToResult(entry);
                        const existing = this.results[format];
                        if (!existing || (existing._dataOrigin !== 'live')) {
                            this.results[format] = converted;
                            hasData = true;
                        } else if (existing && new Date(entry.timestamp) > new Date(existing.testDate)) {
                            this.results[format] = converted;
                            hasData = true;
                        }
                    });
                } catch (error) {
                    console.error('Error loading archive results:', error);
                }

                if (hasData) {
                    this.updateLastUpdated();
                }

                return hasData;
            }

            convertHistoryToResult(entry) {
                const sourceInfo = entry.sourceInfo || {};
                return {
                    testDate: entry.testDate || entry.timestamp,
                    testType: entry.testConfiguration?.testType || 'unknown',
                    iterations: entry.testConfiguration?.iterations || 0,
                    testDuration: entry.testConfiguration?.testDuration || 0,
                    results: entry.results,
                    statisticalAnalysis: entry.statisticalAnalysis || {},
                    performanceRanking: entry.performanceRanking || [],
                    testMetadata: {
                        userAgent: entry.systemInfo?.userAgent || 'Unknown',
                        timestamp: entry.systemInfo?.timestamp || 0,
                        testingEnvironment: 'Archive',
                        browserSpecific: true
                    },
                    _sourceInfo: {
                        originalSource: sourceInfo.originalSource || (this.inferFormatFromResults(entry.results) + '.html'),
                        fileName: sourceInfo.fileName || 'Current Data',
                        importedAt: sourceInfo.importedAt || null
                    },
                    _dataOrigin: 'archive'
                };
            }

            updateLastUpdated() {
                const lastUpdatedElement = document.getElementById('lastUpdated');
                const dates = Object.values(this.results)
                    .map(r => new Date(r.testDate))
                    .filter(d => !isNaN(d));
                
                if (dates.length > 0) {
                    const latest = new Date(Math.max(...dates));
                    lastUpdatedElement.textContent = this.formatDate(latest);
                } else {
                    lastUpdatedElement.textContent = this.t('summary.never');
                }
            }

            setupEventListeners() {
                document.getElementById('exportCsv').addEventListener('click', () => this.exportCsv());
                document.getElementById('exportJson').addEventListener('click', () => this.exportJson());
                document.getElementById('clearData').addEventListener('click', () => this.clearAllData());
                document.getElementById('summaryClearFilters').addEventListener('click', () => this.clearFilters());

                // Auto-apply filters on change
                const filterIds = ['summaryFilterTestType', 'summaryFilterDate', 'summaryFilterSignificance', 'summaryFilterOriginalSource', 'summaryFilterInputSource', 'summaryFilterFileName'];
                filterIds.forEach(id => {
                    document.getElementById(id).addEventListener('change', () => this.onFilterChange());
                });
            }

            populateFilterDropdowns() {
                // Test type
                const typeSelect = document.getElementById('summaryFilterTestType');
                const types = new Set();
                this.archiveHistory.forEach(r => {
                    const t = r.testConfiguration?.testType;
                    if (t) types.add(t);
                });
                const order = ['single', 'bulk', 'stress', 'statistical', 'massive', 'ultra', 'extreme', 'css'];
                const descMap = {
                    'css': 'CSS Test (legacy)', 'single': 'Single Icon Tests', 'bulk': 'Bulk Icon Tests',
                    'stress': 'Stress Tests', 'statistical': 'Statistical Power Tests',
                    'massive': 'Maximum Power Tests', 'ultra': 'Ultra Power Tests', 'extreme': 'Extreme Power Tests'
                };
                const ordered = order.filter(t => types.has(t));
                types.forEach(t => { if (!ordered.includes(t)) ordered.push(t); });
                ordered.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t;
                    opt.textContent = descMap[t] || t;
                    typeSelect.appendChild(opt);
                });

                // Original source
                const srcSelect = document.getElementById('summaryFilterOriginalSource');
                const sources = new Set();
                this.archiveHistory.forEach(r => {
                    const src = r.sourceInfo?.originalSource || (this.inferFormatFromResults(r.results) + '.html');
                    if (src && src !== 'null.html' && src !== 'unknown') sources.add(src);
                });
                // Also add from live per-format keys
                this.testFormats.forEach(f => {
                    try {
                        if (localStorage.getItem(`iconTestResults_${f}`)) sources.add(`${f}.html`);
                    } catch(e) {}
                });
                Array.from(sources).sort().forEach(src => {
                    const opt = document.createElement('option');
                    opt.value = src;
                    opt.textContent = src;
                    srcSelect.appendChild(opt);
                });

                // File name
                const fnSelect = document.getElementById('summaryFilterFileName');
                const fnames = new Set();
                this.archiveHistory.forEach(r => {
                    const fn = r.sourceInfo?.fileName;
                    if (fn && fn !== 'Current Data') fnames.add(fn);
                });
                Array.from(fnames).sort().forEach(fn => {
                    const opt = document.createElement('option');
                    opt.value = fn;
                    opt.textContent = fn;
                    fnSelect.appendChild(opt);
                });
            }

            restoreFilterState() {
                try {
                    const raw = localStorage.getItem('iconTestFilters');
                    if (!raw) return;
                    const state = JSON.parse(raw);
                    if (state.testType) document.getElementById('summaryFilterTestType').value = state.testType;
                    if (state.dateRange) document.getElementById('summaryFilterDate').value = state.dateRange;
                    if (state.significance) document.getElementById('summaryFilterSignificance').value = state.significance;
                    if (state.originalSource) document.getElementById('summaryFilterOriginalSource').value = state.originalSource;
                    if (state.inputSource) document.getElementById('summaryFilterInputSource').value = state.inputSource;
                    if (state.fileName) document.getElementById('summaryFilterFileName').value = state.fileName;
                    // Reload with restored filters
                    if (this.hasActiveFilters()) {
                        this.loadResults();
                    }
                } catch(e) {
                    console.error('Error restoring filter state:', e);
                }
            }

            saveFilterState() {
                const state = this.getFilterState();
                localStorage.setItem('iconTestFilters', JSON.stringify(state));
            }

            onFilterChange() {
                this.saveFilterState();
                this.loadResults();
                this.render();
                this.updateFilterUI();
            }

            clearFilters() {
                document.getElementById('summaryFilterTestType').value = '';
                document.getElementById('summaryFilterDate').value = '';
                document.getElementById('summaryFilterSignificance').value = '';
                document.getElementById('summaryFilterOriginalSource').value = '';
                document.getElementById('summaryFilterInputSource').value = '';
                document.getElementById('summaryFilterFileName').value = '';
                this.saveFilterState();
                this.loadResults();
                this.render();
                this.updateFilterUI();
            }

            updateFilterUI() {
                const clearBtn = document.getElementById('summaryClearFilters');
                const countEl = document.getElementById('summaryFilterCount');
                const active = this.hasActiveFilters();

                if (active) {
                    clearBtn.classList.remove('hidden');
                    countEl.textContent = `${Object.keys(this.results).length} formats shown`;
                } else {
                    clearBtn.classList.add('hidden');
                    countEl.textContent = '';
                }
            }

            render() {
                const hasData = Object.keys(this.results).length > 0;
                const filterSection = document.getElementById('summaryFilterSection');
                // Show filters whenever there's any underlying data (archive or live), even if current filters yield nothing
                const hasAnyData = this.archiveHistory.length > 0 || this.testFormats.some(f => { try { return !!localStorage.getItem(`iconTestResults_${f}`); } catch(e) { return false; } });
                
                if (filterSection) {
                    if (hasAnyData) {
                        filterSection.classList.remove('hidden');
                    } else {
                        filterSection.classList.add('hidden');
                    }
                }
                this.updateFilterUI();

                if (!hasData) {
                    document.getElementById('noDataMessage').classList.remove('hidden');
                    document.getElementById('comparisonSection').classList.add('hidden');
                    return;
                }

                document.getElementById('noDataMessage').classList.add('hidden');
                document.getElementById('comparisonSection').classList.remove('hidden');

                this.renderSummaryCards();
                this.renderPerformanceChart();
                this.renderResultsTable();
                this.renderStatisticalAnalysis();
                this.renderTestEnvironment();
            }

            renderSummaryCards() {
                const container = document.getElementById('summaryCards');
                
                if (Object.keys(this.results).length === 0) {
                    container.innerHTML = '';
                    return;
                }

                // Calculate overall statistics
                const allResults = Object.values(this.results);
                const totalIterations = allResults.reduce((sum, r) => sum + (r.iterations || 0), 0);
                const totalDuration = allResults.reduce((sum, r) => sum + (r.testDuration || 0), 0);
                const archiveCount = allResults.filter(r => r._dataOrigin === 'archive').length;
                const liveCount = allResults.filter(r => r._dataOrigin === 'live').length;
                
                const bestFormat = this.getBestPerformingFormat();
                const worstFormat = this.getWorstPerformingFormat();
                const testCoverage = `${Object.keys(this.results).length}/${this.testFormats.length}`;

                container.innerHTML = `
                    <div class="bg-gradient-to-br from-green-500 to-emerald-600 text-white rounded-xl p-6">
                        <h3 class="text-lg font-semibold mb-2">${this.t('summary.card.best_performance')}</h3>
                        <div class="text-2xl font-bold">${bestFormat.format.toUpperCase()}</div>
                        <div class="text-sm opacity-90">${bestFormat.time.toFixed(3)}ms ${this.t('summary.card.ms_average')}</div>
                    </div>

                    <div class="bg-gradient-to-br from-amber-500 to-orange-600 text-white rounded-xl p-6">
                        <h3 class="text-lg font-semibold mb-2">${this.t('summary.card.test_coverage')}</h3>
                        <div class="text-2xl font-bold">${testCoverage}</div>
                        <div class="text-sm opacity-90">${this.t('summary.card.formats_tested')}</div>
                    </div>

                    <div class="bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-xl p-6">
                        <h3 class="text-lg font-semibold mb-2">${this.t('summary.card.total_analysis')}</h3>
                        <div class="text-2xl font-bold">${this.formatNumber(totalIterations)}</div>
                        <div class="text-sm opacity-90">${this.t('summary.card.iterations_completed')}</div>
                    </div>

                    <div class="bg-gradient-to-br from-purple-500 to-pink-600 text-white rounded-xl p-6">
                        <h3 class="text-lg font-semibold mb-2">${this.t('summary.card.testing_time')}</h3>
                        <div class="text-2xl font-bold">${totalDuration.toFixed(1)}s</div>
                        <div class="text-sm opacity-90">${this.t('summary.card.total_duration')}</div>
                    </div>

                    <div class="bg-gradient-to-br from-red-500 to-rose-600 text-white rounded-xl p-6">
                        <h3 class="text-lg font-semibold mb-2">${this.t('summary.card.slowest_format')}</h3>
                        <div class="text-2xl font-bold">${worstFormat.format.toUpperCase()}</div>
                        <div class="text-sm opacity-90">${worstFormat.time.toFixed(3)}ms ${this.t('summary.card.ms_average')}</div>
                    </div>

                    <div class="bg-gradient-to-br from-gray-600 to-gray-800 text-white rounded-xl p-6">
                        <h3 class="text-lg font-semibold mb-2">${this.t('summary.card.data_sources')}</h3>
                        <div class="text-2xl font-bold">${liveCount + archiveCount}</div>
                        <div class="text-sm opacity-90">${liveCount} ${this.t('summary.card.live')} / ${archiveCount} ${this.t('summary.card.archive')}</div>
                    </div>
                `;
            }

            getBestPerformingFormat() {
                let best = { format: 'none', time: Infinity };
                
                Object.entries(this.results).forEach(([format, data]) => {
                    if (data.performanceRanking && data.performanceRanking.length > 0) {
                        const bestResult = data.performanceRanking.find(r => r.rank === 1);
                        if (bestResult && bestResult.averageTime < best.time) {
                            best = { format, time: bestResult.averageTime };
                        }
                    }
                });

                return best;
            }

            getWorstPerformingFormat() {
                let worst = { format: 'none', time: 0 };
                
                Object.entries(this.results).forEach(([format, data]) => {
                    if (data.performanceRanking && data.performanceRanking.length > 0) {
                        const worstResult = data.performanceRanking[data.performanceRanking.length - 1];
                        if (worstResult && worstResult.averageTime > worst.time) {
                            worst = { format, time: worstResult.averageTime };
                        }
                    }
                });

                return worst;
            }

            renderPerformanceChart() {
                const ctx = document.getElementById('performanceChart').getContext('2d');
                
                // Prepare data for chart
                const datasets = [];
                const labels = [];
                const colors = {
                    css: '#3B82F6',
                    svg: '#10B981',
                    png: '#8B5CF6',
                    gif: '#F59E0B',
                    jpeg: '#EF4444',
                    webp: '#6366F1',
                    avif: '#6B7280'
                };

                Object.entries(this.results).forEach(([format, data]) => {
                    if (data.performanceRanking && data.performanceRanking.length > 0) {
                        data.performanceRanking.forEach(result => {
                            if (!labels.includes(result.iconType)) {
                                labels.push(result.iconType);
                            }
                        });
                    }
                });

                Object.entries(this.results).forEach(([format, data]) => {
                    if (data.performanceRanking && data.performanceRanking.length > 0) {
                        const chartData = labels.map(label => {
                            const result = data.performanceRanking.find(r => r.iconType === label);
                            return result ? result.averageTime : null;
                        });

                        const labelSuffix = data._dataOrigin === 'archive' ? ' (Archive)' : '';
                        datasets.push({
                            label: format.toUpperCase() + labelSuffix,
                            data: chartData,
                            backgroundColor: colors[format] || '#6B7280',
                            borderColor: colors[format] || '#6B7280',
                            borderWidth: 2
                        });
                    }
                });

                // Destroy previous chart instance to allow re-rendering
                if (this.chartInstance) {
                    this.chartInstance.destroy();
                    this.chartInstance = null;
                }

                this.chartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: { labels, datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: this.t('summary.chart.render_title')
                            },
                            legend: { display: true }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: this.t('summary.chart.y_axis')
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: this.t('summary.chart.x_axis')
                                }
                            }
                        }
                    }
                });
            }

            renderResultsTable() {
                const tbody = document.getElementById('resultsTableBody');
                let html = '';

                Object.entries(this.results).forEach(([format, data]) => {
                    const statusClass = data.iterations > 1000 ? 'text-green-600' : 'text-yellow-600';
                    const status = data.iterations > 1000 ? this.t('summary.status.complete') : this.t('summary.status.partial');
                    
                    const bestResult = data.performanceRanking?.find(r => r.rank === 1);
                    const bestPerformance = bestResult ? `${bestResult.iconType} (${bestResult.averageTime.toFixed(3)}ms)` : 'N/A';
                    
                    const avgWithCI = bestResult ? 
                        `${bestResult.averageTime.toFixed(3)} ¬± [${bestResult.confidenceInterval.lower.toFixed(3)}, ${bestResult.confidenceInterval.upper.toFixed(3)}]` :
                        'N/A';

                    const source = data._sourceInfo || {};
                    const originalSource = source.originalSource || `${format}.html`;
                    const fileName = source.fileName || 'Current Data';
                    const importedAt = source.importedAt ? this.formatDate(source.importedAt) : 'N/A';
                    const isArchive = data._dataOrigin === 'archive';
                    const sourceBadge = isArchive 
                        ? '<span class="inline-block px-1.5 py-0.5 text-xs rounded bg-indigo-100 text-indigo-700">Archive</span>'
                        : '<span class="inline-block px-1.5 py-0.5 text-xs rounded bg-green-100 text-green-700">Live</span>';

                    html += `
                        <tr class="border-b hover:bg-gray-50">
                            <td class="p-3 font-medium uppercase">${format} ${sourceBadge}</td>
                            <td class="p-3 text-center text-sm">${this.formatDate(data.testDate)}</td>
                            <td class="p-3 text-center">${this.formatNumber(data.iterations || 0)}</td>
                            <td class="p-3 text-center text-sm">${bestPerformance}</td>
                            <td class="p-3 text-center">${avgWithCI}</td>
                            <td class="p-3 text-center">${(data.testDuration || 0).toFixed(1)}s</td>
                            <td class="p-3 text-center text-xs">${originalSource}</td>
                            <td class="p-3 text-center text-xs max-w-[150px] truncate" title="${fileName}">${fileName}</td>
                            <td class="p-3 text-center text-xs">${importedAt}</td>
                            <td class="p-3 text-center ${statusClass}">${status}</td>
                        </tr>
                    `;
                });

                tbody.innerHTML = html;
            }

            renderStatisticalAnalysis() {
                const container = document.getElementById('statisticalAnalysis');
                let html = '';

                Object.entries(this.results).forEach(([format, data]) => {
                    if (data.statisticalAnalysis && Object.keys(data.statisticalAnalysis).length > 0) {
                        const originLabel = data._dataOrigin === 'archive' ? ' (Archive)' : '';
                        html += `
                            <div class="border border-gray-200 rounded-lg p-4">
                                <h3 class="font-semibold text-lg text-gray-800 mb-3">${format.toUpperCase()}${originLabel} ${this.t('summary.stats.format_analysis')}</h3>
                                <div class="grid md:grid-cols-2 gap-4 text-sm">
                        `;

                        Object.entries(data.statisticalAnalysis).forEach(([comparison, stats]) => {
                            const significanceColor = stats.isSignificant ? 'text-green-600' : 'text-red-600';
                            const powerColor = stats.power > 0.8 ? 'text-green-600' : stats.power > 0.5 ? 'text-yellow-600' : 'text-red-600';
                            const sigLabel = stats.isSignificant 
                                ? this.t('summary.stats.sig_' + stats.significanceLevel) 
                                : this.t('summary.stats.not_significant');
                            
                            html += `
                                <div class="bg-gray-50 p-3 rounded">
                                    <div class="font-medium mb-1">${comparison}</div>
                                    <div class="space-y-1">
                                        <div>${this.t('summary.stats.p_value')} ${stats.pValue < 0.001 ? '<0.001' : stats.pValue.toFixed(3)} <span class="${significanceColor}">(${sigLabel})</span></div>
                                        <div>${this.t('summary.stats.power')} <span class="${powerColor}">${stats.power.toFixed(2)}</span></div>
                                        <div>${this.t('summary.stats.effect_size')} ${stats.effectSize.toFixed(2)}</div>
                                    </div>
                                </div>
                            `;
                        });

                        html += `</div></div>`;
                    }
                });

                if (html === '') {
                    html = '<div class="text-gray-500 text-center">' + this.t('summary.stats.no_data') + '</div>';
                }

                container.innerHTML = html;
            }

            renderTestEnvironment() {
                const container = document.getElementById('testEnvironment');
                
                // Use the first available result for environment info
                const firstResult = Object.values(this.results)[0];
                if (!firstResult || !firstResult.testMetadata) {
                    container.innerHTML = '<div class="text-gray-500">' + this.t('summary.env.no_info') + '</div>';
                    return;
                }

                const metadata = firstResult.testMetadata;
                const timerAvail = performance.timeOrigin ? this.t('summary.env.available') : this.t('summary.env.unavailable');
                const memoryAvail = performance.memory ? this.t('summary.env.available') : this.t('summary.env.unavailable');
                const navAvail = performance.navigation ? this.t('summary.env.available') : this.t('summary.env.unavailable');
                container.innerHTML = `
                    <div class="space-y-2">
                        <h4 class="font-medium text-gray-800">${this.t('summary.env.browser_info')}</h4>
                        <div class="text-gray-600">${metadata.userAgent}</div>
                    </div>
                    
                    <div class="space-y-2">
                        <h4 class="font-medium text-gray-800">${this.t('summary.env.perf_metrics')}</h4>
                        <div class="space-y-1 text-gray-600">
                            <div>${this.t('summary.env.timer')} ${timerAvail}</div>
                            <div>${this.t('summary.env.memory')} ${memoryAvail}</div>
                            <div>${this.t('summary.env.navigation')} ${navAvail}</div>
                        </div>
                    </div>
                `;
            }

            exportCsv() {
                if (Object.keys(this.results).length === 0) {
                    alert(this.t('summary.no_export_data'));
                    return;
                }

                const rows = [
                    ['Format', 'Test Date', 'Iterations', 'Implementation', 'Rank', 'Average Time (ms)', 'CI Lower', 'CI Upper', 'Std Dev', 'Sample Size', 'Source Page', 'Data Source', 'Imported']
                ];

                Object.entries(this.results).forEach(([format, data]) => {
                    if (data.performanceRanking) {
                        const source = data._sourceInfo || {};
                        data.performanceRanking.forEach(result => {
                            rows.push([
                                format.toUpperCase(),
                                new Date(data.testDate).toISOString(),
                                data.iterations || 0,
                                result.iconType,
                                result.rank,
                                result.averageTime.toFixed(6),
                                result.confidenceInterval.lower.toFixed(6),
                                result.confidenceInterval.upper.toFixed(6),
                                result.standardDeviation.toFixed(6),
                                result.sampleSize,
                                source.originalSource || `${format}.html`,
                                source.fileName || 'Current Data',
                                source.importedAt || 'N/A'
                            ]);
                        });
                    }
                });

                const csvContent = rows.map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
                this.downloadFile('icon_performance_results.csv', csvContent, 'text/csv');
            }

            exportJson() {
                if (Object.keys(this.results).length === 0) {
                    alert(this.t('summary.no_export_data'));
                    return;
                }

                const jsonContent = JSON.stringify(this.results, null, 2);
                this.downloadFile('icon_performance_results.json', jsonContent, 'application/json');
            }

            downloadFile(filename, content, contentType) {
                const blob = new Blob([content], { type: contentType });
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);
            }

            clearAllData() {
                if (confirm(this.t('summary.clear_confirm'))) {
                    this.testFormats.forEach(format => {
                        localStorage.removeItem(`iconTestResults_${format}`);
                    });
                    this.results = {};
                    this.render();
                    alert(this.t('summary.clear_success'));
                }
            }
        }

        // Initialize after i18n is ready so translations are available for dynamic content
        let dashboardInstance = null;
        function initDashboard() {
            if (!dashboardInstance) {
                dashboardInstance = new SummaryDashboard();
            } else {
                // Re-render on language change
                dashboardInstance.loadResults();
                dashboardInstance.render();
            }
        }

        document.addEventListener('i18nReady', initDashboard);
        document.addEventListener('languageChanged', function() {
            if (dashboardInstance) {
                dashboardInstance.loadResults();
                dashboardInstance.render();
            }
        });

        // Fallback: if i18n was already ready before this listener was attached
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() {
                if (!dashboardInstance) initDashboard();
            }, 500);
        });
    </script>
</body>
</html>