<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Performance Summary Dashboard - Icon Rendering Tests</title>
    <link rel="icon" href="https://simpsonconcepts.com/img/favicon_io/favicon.ico" type="image/x-icon">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js for visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Internationalization System -->
    <script src="js/i18n.js"></script>
</head>
<body class="min-h-screen bg-gray-50">
    <div class="container mx-auto px-8 py-12">
        <!-- Language Selector -->
        <div class="text-right mb-4">
            <select id="languageSelector" class="px-3 py-2 text-sm border border-gray-300 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="en">English</option>
                <option value="en-us">English (United States)</option>
                <option value="en-gb">English (United Kingdom)</option>
                <option value="es">Espa√±ol</option>
                <option value="fr">Fran√ßais</option>
                <option value="de">Deutsch</option>
                <option value="ja">Êó•Êú¨Ë™û</option>
                <option value="zh">‰∏≠Êñá</option>
                <option value="zh-tw">‰∏≠Êñá (ÁπÅÈ´î)</option>
                <option value="pt">Portugu√™s</option>
                <option value="pt-br">Portugu√™s (Brasil)</option>
                <option value="pt-pt">Portugu√™s (Portugal)</option>
            </select>
        </div>
        
        <!-- Header -->
        <header class="text-center mb-12">
            <h1 class="text-4xl font-bold text-gray-800 mb-4" data-i18n="summary.title">Performance Summary Dashboard</h1>
            <p class="text-xl text-gray-600 max-w-3xl mx-auto" data-i18n="summary.subtitle">
                Comprehensive analysis and comparison of icon rendering performance across all tested formats.
            </p>
            
            <!-- Browser-specific notice -->
            <div class="mt-4 p-3 bg-yellow-50 border border-yellow-300 rounded-lg text-sm max-w-4xl mx-auto">
                <div class="flex items-center justify-center">
                    <span class="mr-2 text-yellow-600">üåê</span>
                    <div>
                        <strong class="text-yellow-800" data-i18n="summary.browser_notice">Browser-Specific Results:</strong>
                        <span class="text-yellow-700 ml-1" data-i18n="summary.browser_notice_desc">All performance data shown is specific to the browser environment where tests were executed</span>
                    </div>
                </div>
            </div>
            
            <div class="mt-6 space-x-4">
                <a href="index.html" class="inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors" data-i18n="summary.back_to_tests">
                    ‚Üê Back to Test Suite
                </a>
                <a href="past-results.html" class="inline-flex items-center px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors" data-i18n="summary.view_past_results">
                    üìä View Past Results
                </a>
            </div>
        </header>

        <!-- Data Export & Controls -->
        <div class="flex justify-between items-center mb-8">
            <div class="flex space-x-4 flex-wrap gap-2">
                <button id="exportCsv" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors" data-i18n="summary.export_csv">
                    Export CSV
                </button>
                <button id="exportJson" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors" data-i18n="summary.export_json">
                    Export JSON
                </button>
                <button id="clearData" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors" data-i18n="summary.clear_data">
                    Clear All Data
                </button>
            </div>
            <div class="text-sm text-gray-500">
                <span data-i18n="summary.last_updated">Last updated:</span> <span id="lastUpdated" data-i18n="summary.never">Never</span>
            </div>
        </div>

        <!-- Summary Cards -->
        <div id="summaryCards" class="grid md:grid-cols-2 lg:grid-cols-3 gap-6 mb-12">
            <!-- Cards will be populated dynamically -->
        </div>

        <!-- Error/No Data Message -->
        <div id="noDataMessage" class="hidden bg-yellow-50 border border-yellow-200 p-6 rounded-lg text-center">
            <h3 class="text-lg font-semibold text-yellow-800 mb-2" data-i18n="summary.no_data_title">No Test Data Available</h3>
            <p class="text-yellow-700 mb-4" data-i18n="summary.no_data_desc">
                No performance test results found. Run some tests or import previous results from the Past Results Archive.
            </p>
            <div class="space-x-4">
                <a href="index.html" class="inline-block px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700 transition-colors" data-i18n="summary.run_tests">
                    Go Back to Run Tests
                </a>
                <a href="past-results.html" class="inline-block px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors" data-i18n="summary.view_past_results">
                    üìä View Past Results
                </a>
            </div>
        </div>

        <!-- Filter Controls -->
        <div id="summaryFilterSection" class="bg-white p-6 rounded-xl shadow-lg mb-8 hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-semibold text-gray-800" data-i18n="summary.filter_title">Filter Results</h2>
                <div class="flex items-center gap-3">
                    <span id="summaryFilterCount" class="text-sm text-gray-500"></span>
                    <button id="summaryClearFilters" class="px-3 py-1.5 text-sm bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors hidden" data-i18n="past.clear_filters">
                        Clear Filters
                    </button>
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-6 gap-4">
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1" for="summaryFilterTestType" data-i18n="past.filter.test_type">Test Type:</label>
                    <select id="summaryFilterTestType" class="w-full p-1.5 border rounded text-sm">
                        <option value="" data-i18n="past.filter.all_types">All Types</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1" for="summaryFilterDate" data-i18n="past.filter.date_range">Date Range:</label>
                    <select id="summaryFilterDate" class="w-full p-1.5 border rounded text-sm">
                        <option value="" data-i18n="past.filter.all_time">All Time</option>
                        <option value="today" data-i18n="past.filter.today">Today</option>
                        <option value="week" data-i18n="past.filter.week">Past Week</option>
                        <option value="month" data-i18n="past.filter.month">Past Month</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1" for="summaryFilterSignificance" data-i18n="past.filter.significance">Significance:</label>
                    <select id="summaryFilterSignificance" class="w-full p-1.5 border rounded text-sm">
                        <option value="" data-i18n="past.filter.all_results">All Results</option>
                        <option value="significant" data-i18n="past.filter.significant">Significant Only</option>
                        <option value="not-significant" data-i18n="past.filter.not_significant">Not Significant Only</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1" for="summaryFilterOriginalSource" data-i18n="past.filter.original_source">Original Source:</label>
                    <select id="summaryFilterOriginalSource" class="w-full p-1.5 border rounded text-sm">
                        <option value="" data-i18n="past.filter.all_sources">All Sources</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1" for="summaryFilterInputSource" data-i18n="past.filter.input_source">Input Source:</label>
                    <select id="summaryFilterInputSource" class="w-full p-1.5 border rounded text-sm">
                        <option value="" data-i18n="past.filter.all_inputs">All Inputs</option>
                        <option value="Current Data" data-i18n="past.filter.current_data">Current Data (Live Tests)</option>
                        <option value="file" data-i18n="past.filter.imported_file">Imported File</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1" for="summaryFilterFileName" data-i18n="past.filter.file_name">File Name:</label>
                    <select id="summaryFilterFileName" class="w-full p-1.5 border rounded text-sm">
                        <option value="" data-i18n="past.filter.all_files">All Files</option>
                    </select>
                </div>
            </div>

            <!-- Test Exclusion Filter -->
            <div class="mt-4 pt-4 border-t border-gray-200">
                <div class="flex justify-between items-center mb-2">
                    <label class="block text-xs font-medium text-gray-700">Exclude Specific Tests:</label>
                    <div class="flex gap-2">
                        <button id="excludeSelectAll" class="text-xs text-red-600 hover:underline" type="button">Exclude All</button>
                        <button id="excludeDeselectAll" class="text-xs text-green-600 hover:underline" type="button">Include All</button>
                    </div>
                </div>
                <div id="testExclusionList" class="max-h-60 overflow-y-auto p-2.5 border border-gray-100 rounded-lg bg-gray-50/50 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-x-4 gap-y-3 items-start">
                    <span class="text-xs text-gray-400">Loading tests...</span>
                </div>
                <p class="text-xs text-gray-400 mt-1">Check a test to exclude it from all charts, tables, and statistical analysis.</p>
            </div>
        </div>

        <!-- Performance Comparison Chart -->
        <div id="comparisonSection" class="hidden">
            <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-6" data-i18n="summary.chart_title">Cross-Format Performance Comparison</h2>
                <div class="h-96">
                    <canvas id="performanceChart"></canvas>
                </div>
            </div>

            <!-- Detailed Results Table -->
            <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-6" data-i18n="summary.results_title">Detailed Test Results</h2>
                <div class="overflow-x-auto">
                    <table id="resultsTable" class="w-full text-sm">
                        <thead>
                            <tr class="bg-gray-50 border-b">
                                <th class="p-3 text-left" data-i18n="summary.table.format">Format</th>
                                <th class="p-3 text-center" data-i18n="summary.table.date">Test Date</th>
                                <th class="p-3 text-center" data-i18n="summary.table.iterations">Iterations</th>
                                <th class="p-3 text-center" data-i18n="summary.table.best">Best Performance</th>
                                <th class="p-3 text-center" data-i18n="summary.table.average">Avg ¬± CI (ms)</th>
                                <th class="p-3 text-center" data-i18n="summary.table.duration">Test Duration</th>
                                <th class="p-3 text-center" data-i18n="summary.table.source_page">Source Page</th>
                                <th class="p-3 text-center" data-i18n="summary.table.data_source">Data Source</th>
                                <th class="p-3 text-center" data-i18n="summary.table.imported">Imported</th>
                                <th class="p-3 text-center" data-i18n="summary.table.status">Status</th>
                            </tr>
                        </thead>
                        <tbody id="resultsTableBody">
                            <!-- Table rows will be populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Statistical Analysis -->
            <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-2xl font-semibold text-gray-800 mb-6" data-i18n="summary.stats_title">Statistical Analysis Overview</h2>
                <div id="statisticalAnalysis" class="space-y-4">
                    <!-- Statistical analysis will be populated dynamically -->
                </div>
            </div>

            <!-- Test Environment Information -->
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-6" data-i18n="summary.environment_title">Test Environment</h2>
                <div id="testEnvironment" class="grid md:grid-cols-2 gap-4 text-sm">
                    <!-- Environment info will be populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <script>
        class SummaryDashboard {
            constructor() {
                this.testFormats = ['css', 'svg', 'png', 'gif', 'jpeg', 'webp', 'avif'];
                this.results = {};
                this.archiveHistory = [];
                this.chartInstance = null;
                this.excludedTests = new Set();
                this.loadArchiveHistory();
                this.loadExcludedTests();
                this.loadResults();
                this.setupEventListeners();
                this.populateFilterDropdowns();
                this.restoreFilterState();
                this.render();
            }

            t(key) {
                return window.i18n ? window.i18n.translate(key) : key;
            }

            getLocale() {
                return window.i18n?.currentLanguage || navigator.language || 'en';
            }

            formatDate(dateStr) {
                if (!dateStr) return 'N/A';
                const d = new Date(dateStr);
                return isNaN(d) ? 'N/A' : d.toLocaleString(this.getLocale());
            }

            formatNumber(num) {
                return typeof num === 'number' ? num.toLocaleString(this.getLocale()) : num;
            }

            inferFormatFromResults(results) {
                if (!results || typeof results !== 'object') return null;
                const keys = Object.keys(results);
                if (keys.length === 0) return null;
                const firstKey = keys[0].toLowerCase();
                if (firstKey.includes('css'))   return 'css';
                if (firstKey.includes('svg'))   return 'svg';
                if (firstKey.includes('png'))   return 'png';
                if (firstKey.includes('gif'))   return 'gif';
                if (firstKey.includes('jpeg'))  return 'jpeg';
                if (firstKey.includes('webp'))  return 'webp';
                if (firstKey.includes('avif'))  return 'avif';
                return null;
            }

            loadArchiveHistory() {
                try {
                    const raw = localStorage.getItem('iconTestHistory');
                    this.archiveHistory = raw ? JSON.parse(raw) : [];
                } catch (e) {
                    console.error('Error loading archive history:', e);
                    this.archiveHistory = [];
                }
            }

            getFilterState() {
                return {
                    testType: document.getElementById('summaryFilterTestType')?.value || '',
                    dateRange: document.getElementById('summaryFilterDate')?.value || '',
                    significance: document.getElementById('summaryFilterSignificance')?.value || '',
                    originalSource: document.getElementById('summaryFilterOriginalSource')?.value || '',
                    inputSource: document.getElementById('summaryFilterInputSource')?.value || '',
                    fileName: document.getElementById('summaryFilterFileName')?.value || ''
                };
            }

            hasActiveFilters() {
                const f = this.getFilterState();
                return !!(f.testType || f.dateRange || f.significance || f.originalSource || f.inputSource || f.fileName || this.excludedTests.size > 0);
            }

            filterArchiveEntries(entries) {
                const f = this.getFilterState();
                if (!f.testType && !f.dateRange && !f.significance && !f.originalSource && !f.inputSource && !f.fileName) {
                    return entries;
                }
                let filtered = [...entries];
                if (f.testType) {
                    filtered = filtered.filter(r => r.testConfiguration?.testType === f.testType);
                }
                if (f.dateRange) {
                    const now = new Date();
                    let cutoff;
                    if (f.dateRange === 'today') cutoff = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    else if (f.dateRange === 'week') cutoff = new Date(now.getTime() - 7*24*60*60*1000);
                    else if (f.dateRange === 'month') cutoff = new Date(now.getTime() - 30*24*60*60*1000);
                    if (cutoff) filtered = filtered.filter(r => new Date(r.timestamp) >= cutoff);
                }
                if (f.significance === 'significant') {
                    filtered = filtered.filter(r => r.summary?.significantDifferences > 0);
                } else if (f.significance === 'not-significant') {
                    filtered = filtered.filter(r => !r.summary?.significantDifferences || r.summary.significantDifferences === 0);
                }
                if (f.originalSource) {
                    filtered = filtered.filter(r => {
                        const src = r.sourceInfo?.originalSource || (this.inferFormatFromResults(r.results) + '.html');
                        return src === f.originalSource;
                    });
                }
                if (f.inputSource === 'Current Data') {
                    filtered = filtered.filter(r => !r.sourceInfo?.fileName || r.sourceInfo.fileName === 'Current Data');
                } else if (f.inputSource === 'file') {
                    filtered = filtered.filter(r => r.sourceInfo?.fileName && r.sourceInfo.fileName !== 'Current Data');
                }
                if (f.fileName) {
                    filtered = filtered.filter(r => r.sourceInfo?.fileName === f.fileName);
                }
                return filtered;
            }

            loadResults() {
                this.results = {};
                let hasData = false;
                const f = this.getFilterState();
                const inputFilter = f.inputSource;
                const fileFilter = f.fileName;

                // 1. Load per-format keys (from live test sessions) ‚Äî skip if filtering to imported only
                if (inputFilter !== 'file' && !fileFilter) {
                    this.testFormats.forEach(format => {
                        try {
                            const data = localStorage.getItem(`iconTestResults_${format}`);
                            if (data) {
                                const parsed = JSON.parse(data);
                                // Apply source filter to live data
                                if (f.originalSource && f.originalSource !== `${format}.html`) return;
                                parsed._sourceInfo = {
                                    originalSource: `${format}.html`,
                                    fileName: 'Current Data',
                                    importedAt: null
                                };
                                parsed._dataOrigin = 'live';
                                this.results[format] = parsed;
                                hasData = true;
                            }
                        } catch (error) {
                            console.error(`Error loading ${format} results:`, error);
                        }
                    });
                }

                // 2. Load from iconTestHistory archive ‚Äî apply filters, then pick latest per format
                try {
                    const filteredHistory = this.filterArchiveEntries(this.archiveHistory);
                    const latestByFormat = {};
                    filteredHistory.forEach(entry => {
                        const format = this.inferFormatFromResults(entry.results);
                        if (!format) return;
                        if (!latestByFormat[format] || new Date(entry.timestamp) > new Date(latestByFormat[format].timestamp)) {
                            latestByFormat[format] = entry;
                        }
                    });

                    Object.entries(latestByFormat).forEach(([format, entry]) => {
                        const converted = this.convertHistoryToResult(entry);
                        const existing = this.results[format];
                        if (!existing || (existing._dataOrigin !== 'live')) {
                            this.results[format] = converted;
                            hasData = true;
                        } else if (existing && new Date(entry.timestamp) > new Date(existing.testDate)) {
                            this.results[format] = converted;
                            hasData = true;
                        }
                    });
                } catch (error) {
                    console.error('Error loading archive results:', error);
                }

                if (hasData) {
                    this.updateLastUpdated();
                }

                return hasData;
            }

            convertHistoryToResult(entry) {
                const sourceInfo = entry.sourceInfo || {};
                return {
                    testDate: entry.testDate || entry.timestamp,
                    testType: entry.testConfiguration?.testType || 'unknown',
                    iterations: entry.testConfiguration?.iterations || 0,
                    testDuration: entry.testConfiguration?.testDuration || 0,
                    results: entry.results,
                    statisticalAnalysis: entry.statisticalAnalysis || {},
                    performanceRanking: entry.performanceRanking || [],
                    testMetadata: {
                        userAgent: entry.systemInfo?.userAgent || 'Unknown',
                        timestamp: entry.systemInfo?.timestamp || 0,
                        testingEnvironment: 'Archive',
                        browserSpecific: true
                    },
                    _sourceInfo: {
                        originalSource: sourceInfo.originalSource || (this.inferFormatFromResults(entry.results) + '.html'),
                        fileName: sourceInfo.fileName || 'Current Data',
                        importedAt: sourceInfo.importedAt || null
                    },
                    _dataOrigin: 'archive'
                };
            }

            updateLastUpdated() {
                const lastUpdatedElement = document.getElementById('lastUpdated');
                const dates = Object.values(this.results)
                    .map(r => new Date(r.testDate))
                    .filter(d => !isNaN(d));
                
                if (dates.length > 0) {
                    const latest = new Date(Math.max(...dates));
                    lastUpdatedElement.textContent = this.formatDate(latest);
                } else {
                    lastUpdatedElement.textContent = this.t('summary.never');
                }
            }

            setupEventListeners() {
                document.getElementById('exportCsv').addEventListener('click', () => this.exportCsv());
                document.getElementById('exportJson').addEventListener('click', () => this.exportJson());
                document.getElementById('clearData').addEventListener('click', () => this.clearAllData());
                document.getElementById('summaryClearFilters').addEventListener('click', () => this.clearFilters());
                document.getElementById('excludeSelectAll')?.addEventListener('click', () => this.excludeAllTests());
                document.getElementById('excludeDeselectAll')?.addEventListener('click', () => this.includeAllTests());

                // Auto-apply filters on change
                const filterIds = ['summaryFilterTestType', 'summaryFilterDate', 'summaryFilterSignificance', 'summaryFilterOriginalSource', 'summaryFilterInputSource', 'summaryFilterFileName'];
                filterIds.forEach(id => {
                    document.getElementById(id).addEventListener('change', () => this.onFilterChange());
                });
            }

            populateFilterDropdowns() {
                // Test type
                const typeSelect = document.getElementById('summaryFilterTestType');
                const types = new Set();
                this.archiveHistory.forEach(r => {
                    const t = r.testConfiguration?.testType;
                    if (t) types.add(t);
                });
                const order = ['single', 'bulk', 'stress', 'statistical', 'massive', 'ultra', 'extreme', 'css'];
                const descMap = {
                    'css': 'CSS Test (legacy)', 'single': 'Single Icon Tests', 'bulk': 'Bulk Icon Tests',
                    'stress': 'Stress Tests', 'statistical': 'Statistical Power Tests',
                    'massive': 'Maximum Power Tests', 'ultra': 'Ultra Power Tests', 'extreme': 'Extreme Power Tests'
                };
                const ordered = order.filter(t => types.has(t));
                types.forEach(t => { if (!ordered.includes(t)) ordered.push(t); });
                ordered.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t;
                    opt.textContent = descMap[t] || t;
                    typeSelect.appendChild(opt);
                });

                // Original source
                const srcSelect = document.getElementById('summaryFilterOriginalSource');
                const sources = new Set();
                this.archiveHistory.forEach(r => {
                    const src = r.sourceInfo?.originalSource || (this.inferFormatFromResults(r.results) + '.html');
                    if (src && src !== 'null.html' && src !== 'unknown') sources.add(src);
                });
                // Also add from live per-format keys
                this.testFormats.forEach(f => {
                    try {
                        if (localStorage.getItem(`iconTestResults_${f}`)) sources.add(`${f}.html`);
                    } catch(e) {}
                });
                Array.from(sources).sort().forEach(src => {
                    const opt = document.createElement('option');
                    opt.value = src;
                    opt.textContent = src;
                    srcSelect.appendChild(opt);
                });

                // File name
                const fnSelect = document.getElementById('summaryFilterFileName');
                const fnames = new Set();
                this.archiveHistory.forEach(r => {
                    const fn = r.sourceInfo?.fileName;
                    if (fn && fn !== 'Current Data') fnames.add(fn);
                });
                Array.from(fnames).sort().forEach(fn => {
                    const opt = document.createElement('option');
                    opt.value = fn;
                    opt.textContent = fn;
                    fnSelect.appendChild(opt);
                });
            }

            restoreFilterState() {
                try {
                    const raw = localStorage.getItem('iconTestFilters');
                    if (!raw) return;
                    const state = JSON.parse(raw);
                    if (state.testType) document.getElementById('summaryFilterTestType').value = state.testType;
                    if (state.dateRange) document.getElementById('summaryFilterDate').value = state.dateRange;
                    if (state.significance) document.getElementById('summaryFilterSignificance').value = state.significance;
                    if (state.originalSource) document.getElementById('summaryFilterOriginalSource').value = state.originalSource;
                    if (state.inputSource) document.getElementById('summaryFilterInputSource').value = state.inputSource;
                    if (state.fileName) document.getElementById('summaryFilterFileName').value = state.fileName;
                    // Reload with restored filters
                    if (this.hasActiveFilters()) {
                        this.loadResults();
                    }
                } catch(e) {
                    console.error('Error restoring filter state:', e);
                }
            }

            saveFilterState() {
                const state = this.getFilterState();
                localStorage.setItem('iconTestFilters', JSON.stringify(state));
            }

            onFilterChange() {
                this.saveFilterState();
                this.loadResults();
                this.render();
                this.updateFilterUI();
            }

            clearFilters() {
                document.getElementById('summaryFilterTestType').value = '';
                document.getElementById('summaryFilterDate').value = '';
                document.getElementById('summaryFilterSignificance').value = '';
                document.getElementById('summaryFilterOriginalSource').value = '';
                document.getElementById('summaryFilterInputSource').value = '';
                document.getElementById('summaryFilterFileName').value = '';
                this.excludedTests.clear();
                this.saveExcludedTests();
                this.saveFilterState();
                this.loadResults();
                this.render();
                this.updateFilterUI();
            }

            updateFilterUI() {
                const clearBtn = document.getElementById('summaryClearFilters');
                const countEl = document.getElementById('summaryFilterCount');
                const active = this.hasActiveFilters();

                if (active) {
                    clearBtn.classList.remove('hidden');
                    const excludeNote = this.excludedTests.size > 0 ? ` \u00b7 ${this.excludedTests.size} test(s) excluded` : '';
                    countEl.textContent = `${Object.keys(this.results).length} formats shown${excludeNote}`;
                } else {
                    clearBtn.classList.add('hidden');
                    countEl.textContent = '';
                }
            }

            // --- Test Exclusion Methods ---

            loadExcludedTests() {
                try {
                    const raw = localStorage.getItem('iconTestExcludedTests');
                    this.excludedTests = raw ? new Set(JSON.parse(raw)) : new Set();
                } catch(e) {
                    this.excludedTests = new Set();
                }
            }

            saveExcludedTests() {
                localStorage.setItem('iconTestExcludedTests', JSON.stringify([...this.excludedTests]));
            }

            collectAllIconTypes() {
                // Returns Map<sourceFormat, Set<iconType>> grouped by source page
                const groups = new Map();
                const ensure = (fmt) => { if (!groups.has(fmt)) groups.set(fmt, new Set()); return groups.get(fmt); };

                // Live results ‚Äî keyed by format name directly
                Object.entries(this.results).forEach(([format, data]) => {
                    const grp = ensure(format);
                    if (data.performanceRanking) {
                        data.performanceRanking.forEach(r => grp.add(r.iconType));
                    }
                    if (data.results) {
                        Object.keys(data.results).forEach(k => grp.add(k));
                    }
                });

                // Archive ‚Äî derive format from sourceInfo.originalSource (e.g. "css.html" ‚Üí "css")
                this.archiveHistory.forEach(entry => {
                    const src = entry.sourceInfo?.originalSource || '';
                    const format = src.replace(/\.html$/i, '') || this.inferFormatFromResults(entry.results);
                    if (!format) return;
                    const grp = ensure(format);
                    if (entry.performanceRanking) {
                        entry.performanceRanking.forEach(r => grp.add(r.iconType));
                    }
                    if (entry.results) {
                        Object.keys(entry.results).forEach(k => grp.add(k));
                    }
                });
                return groups;
            }

            collectAllIconTypesFlat() {
                const all = new Set();
                for (const s of this.collectAllIconTypes().values()) s.forEach(t => all.add(t));
                return all;
            }

            renderTestExclusions() {
                const container = document.getElementById('testExclusionList');
                if (!container) return;
                const groups = this.collectAllIconTypes();
                if (groups.size === 0) {
                    container.innerHTML = '<span class="text-xs text-gray-400">No tests available yet</span>';
                    return;
                }
                // Clean up stale exclusions for tests that no longer exist
                const allTypes = this.collectAllIconTypesFlat();
                [...this.excludedTests].forEach(t => { if (!allTypes.has(t)) this.excludedTests.delete(t); });

                container.innerHTML = '';
                const formatOrder = this.testFormats.filter(f => groups.has(f));
                // Add any extra keys not in testFormats
                for (const k of groups.keys()) { if (!formatOrder.includes(k)) formatOrder.push(k); }

                formatOrder.forEach((format) => {
                    const types = groups.get(format);
                    if (!types || types.size === 0) return;

                    const section = document.createElement('div');

                    // Column header
                    const header = document.createElement('div');
                    header.className = 'mb-1 pb-1 border-b border-gray-200/80';
                    header.innerHTML = `<span class="text-xs font-semibold text-gray-500 uppercase tracking-wider">${format.toUpperCase()}</span>`;
                    section.appendChild(header);

                    // Vertical checkbox list
                    const list = document.createElement('div');
                    list.className = 'flex flex-col gap-0.5 pl-1';

                    Array.from(types).sort().forEach(type => {
                        const isExcluded = this.excludedTests.has(type);
                        const label = document.createElement('label');
                        label.className = `inline-flex items-center gap-2 py-0.5 text-xs cursor-pointer select-none transition-colors ${
                            isExcluded ? 'text-red-600 line-through opacity-70' : 'text-gray-700'
                        } hover:opacity-80`;
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.checked = isExcluded;
                        checkbox.className = 'rounded text-red-500 cursor-pointer';
                        checkbox.addEventListener('change', () => {
                            if (checkbox.checked) {
                                this.excludedTests.add(type);
                            } else {
                                this.excludedTests.delete(type);
                            }
                            this.saveExcludedTests();
                            this.render();
                        });
                        const span = document.createElement('span');
                        span.textContent = type;
                        label.appendChild(checkbox);
                        label.appendChild(span);
                        list.appendChild(label);
                    });

                    section.appendChild(list);
                    container.appendChild(section);
                });
            }

            excludeAllTests() {
                const types = this.collectAllIconTypesFlat();
                types.forEach(t => this.excludedTests.add(t));
                this.saveExcludedTests();
                this.render();
            }

            includeAllTests() {
                this.excludedTests.clear();
                this.saveExcludedTests();
                this.render();
            }

            getFilteredRanking(data) {
                if (!data?.performanceRanking) return [];
                if (this.excludedTests.size === 0) return data.performanceRanking;
                return data.performanceRanking.filter(r => !this.excludedTests.has(r.iconType));
            }

            getFilteredStatistics(data) {
                if (!data?.statisticalAnalysis) return {};
                if (this.excludedTests.size === 0) return data.statisticalAnalysis;
                const filtered = {};
                Object.entries(data.statisticalAnalysis).forEach(([comparison, stats]) => {
                    const mentionsExcluded = [...this.excludedTests].some(test => comparison.includes(test));
                    if (!mentionsExcluded) {
                        filtered[comparison] = stats;
                    }
                });
                return filtered;
            }

            render() {
                const hasData = Object.keys(this.results).length > 0;
                const filterSection = document.getElementById('summaryFilterSection');
                // Show filters whenever there's any underlying data (archive or live), even if current filters yield nothing
                const hasAnyData = this.archiveHistory.length > 0 || this.testFormats.some(f => { try { return !!localStorage.getItem(`iconTestResults_${f}`); } catch(e) { return false; } });
                
                if (filterSection) {
                    if (hasAnyData) {
                        filterSection.classList.remove('hidden');
                    } else {
                        filterSection.classList.add('hidden');
                    }
                }
                this.updateFilterUI();
                this.renderTestExclusions();

                if (!hasData) {
                    document.getElementById('noDataMessage').classList.remove('hidden');
                    document.getElementById('comparisonSection').classList.add('hidden');
                    return;
                }

                document.getElementById('noDataMessage').classList.add('hidden');
                document.getElementById('comparisonSection').classList.remove('hidden');

                this.renderSummaryCards();
                this.renderPerformanceChart();
                this.renderResultsTable();
                this.renderStatisticalAnalysis();
                this.renderTestEnvironment();
            }

            renderSummaryCards() {
                const container = document.getElementById('summaryCards');
                
                if (Object.keys(this.results).length === 0) {
                    container.innerHTML = '';
                    return;
                }

                // Calculate overall statistics
                const allResults = Object.values(this.results);
                const totalIterations = allResults.reduce((sum, r) => sum + (r.iterations || 0), 0);
                const totalDuration = allResults.reduce((sum, r) => sum + (r.testDuration || 0), 0);
                const archiveCount = allResults.filter(r => r._dataOrigin === 'archive').length;
                const liveCount = allResults.filter(r => r._dataOrigin === 'live').length;
                
                const bestFormat = this.getBestPerformingFormat();
                const worstFormat = this.getWorstPerformingFormat();
                const testCoverage = `${Object.keys(this.results).length}/${this.testFormats.length}`;

                container.innerHTML = `
                    <div class="bg-gradient-to-br from-green-500 to-emerald-600 text-white rounded-xl p-6">
                        <h3 class="text-lg font-semibold mb-2">${this.t('summary.card.best_performance')}</h3>
                        <div class="text-2xl font-bold">${bestFormat.format.toUpperCase()}</div>
                        <div class="text-sm opacity-90">${bestFormat.time.toFixed(3)}ms ${this.t('summary.card.ms_average')}</div>
                    </div>

                    <div class="bg-gradient-to-br from-amber-500 to-orange-600 text-white rounded-xl p-6">
                        <h3 class="text-lg font-semibold mb-2">${this.t('summary.card.test_coverage')}</h3>
                        <div class="text-2xl font-bold">${testCoverage}</div>
                        <div class="text-sm opacity-90">${this.t('summary.card.formats_tested')}</div>
                    </div>

                    <div class="bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-xl p-6">
                        <h3 class="text-lg font-semibold mb-2">${this.t('summary.card.total_analysis')}</h3>
                        <div class="text-2xl font-bold">${this.formatNumber(totalIterations)}</div>
                        <div class="text-sm opacity-90">${this.t('summary.card.iterations_completed')}</div>
                    </div>

                    <div class="bg-gradient-to-br from-purple-500 to-pink-600 text-white rounded-xl p-6">
                        <h3 class="text-lg font-semibold mb-2">${this.t('summary.card.testing_time')}</h3>
                        <div class="text-2xl font-bold">${totalDuration.toFixed(1)}s</div>
                        <div class="text-sm opacity-90">${this.t('summary.card.total_duration')}</div>
                    </div>

                    <div class="bg-gradient-to-br from-red-500 to-rose-600 text-white rounded-xl p-6">
                        <h3 class="text-lg font-semibold mb-2">${this.t('summary.card.slowest_format')}</h3>
                        <div class="text-2xl font-bold">${worstFormat.format.toUpperCase()}</div>
                        <div class="text-sm opacity-90">${worstFormat.time.toFixed(3)}ms ${this.t('summary.card.ms_average')}</div>
                    </div>

                    <div class="bg-gradient-to-br from-gray-600 to-gray-800 text-white rounded-xl p-6">
                        <h3 class="text-lg font-semibold mb-2">${this.t('summary.card.data_sources')}</h3>
                        <div class="text-2xl font-bold">${liveCount + archiveCount}</div>
                        <div class="text-sm opacity-90">${liveCount} ${this.t('summary.card.live')} / ${archiveCount} ${this.t('summary.card.archive')}</div>
                    </div>
                `;
            }

            getBestPerformingFormat() {
                let best = { format: 'none', time: Infinity };
                
                Object.entries(this.results).forEach(([format, data]) => {
                    const ranking = this.getFilteredRanking(data);
                    if (ranking.length > 0) {
                        const sorted = [...ranking].sort((a, b) => a.averageTime - b.averageTime);
                        if (sorted[0].averageTime < best.time) {
                            best = { format, time: sorted[0].averageTime };
                        }
                    }
                });

                return best;
            }

            getWorstPerformingFormat() {
                let worst = { format: 'none', time: 0 };
                
                Object.entries(this.results).forEach(([format, data]) => {
                    const ranking = this.getFilteredRanking(data);
                    if (ranking.length > 0) {
                        const sorted = [...ranking].sort((a, b) => b.averageTime - a.averageTime);
                        if (sorted[0].averageTime > worst.time) {
                            worst = { format, time: sorted[0].averageTime };
                        }
                    }
                });

                return worst;
            }

            renderPerformanceChart() {
                const ctx = document.getElementById('performanceChart').getContext('2d');
                
                // Prepare data for chart
                const datasets = [];
                const labels = [];
                const colors = {
                    css: '#3B82F6',
                    svg: '#10B981',
                    png: '#8B5CF6',
                    gif: '#F59E0B',
                    jpeg: '#EF4444',
                    webp: '#6366F1',
                    avif: '#6B7280'
                };

                Object.entries(this.results).forEach(([format, data]) => {
                    const ranking = this.getFilteredRanking(data);
                    ranking.forEach(result => {
                        if (!labels.includes(result.iconType)) {
                            labels.push(result.iconType);
                        }
                    });
                });

                Object.entries(this.results).forEach(([format, data]) => {
                    const ranking = this.getFilteredRanking(data);
                    if (ranking.length > 0) {
                        const chartData = labels.map(label => {
                            const result = ranking.find(r => r.iconType === label);
                            return result ? result.averageTime : null;
                        });

                        const labelSuffix = data._dataOrigin === 'archive' ? ' (Archive)' : '';
                        datasets.push({
                            label: format.toUpperCase() + labelSuffix,
                            data: chartData,
                            backgroundColor: colors[format] || '#6B7280',
                            borderColor: colors[format] || '#6B7280',
                            borderWidth: 2
                        });
                    }
                });

                // Destroy previous chart instance to allow re-rendering
                if (this.chartInstance) {
                    this.chartInstance.destroy();
                    this.chartInstance = null;
                }

                this.chartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: { labels, datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: this.t('summary.chart.render_title')
                            },
                            legend: { display: true }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: this.t('summary.chart.y_axis')
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: this.t('summary.chart.x_axis')
                                }
                            }
                        }
                    }
                });
            }

            renderResultsTable() {
                const tbody = document.getElementById('resultsTableBody');
                let html = '';

                Object.entries(this.results).forEach(([format, data]) => {
                    const statusClass = data.iterations > 1000 ? 'text-green-600' : 'text-yellow-600';
                    const status = data.iterations > 1000 ? this.t('summary.status.complete') : this.t('summary.status.partial');
                    
                    const filteredRanking = this.getFilteredRanking(data);
                    const bestResult = filteredRanking.length > 0 ? [...filteredRanking].sort((a, b) => a.averageTime - b.averageTime)[0] : null;
                    const bestPerformance = bestResult ? `${bestResult.iconType} (${bestResult.averageTime.toFixed(3)}ms)` : 'N/A';
                    
                    const avgWithCI = bestResult ? 
                        `${bestResult.averageTime.toFixed(3)} ¬± [${bestResult.confidenceInterval.lower.toFixed(3)}, ${bestResult.confidenceInterval.upper.toFixed(3)}]` :
                        'N/A';

                    const source = data._sourceInfo || {};
                    const originalSource = source.originalSource || `${format}.html`;
                    const fileName = source.fileName || 'Current Data';
                    const importedAt = source.importedAt ? this.formatDate(source.importedAt) : 'N/A';
                    const isArchive = data._dataOrigin === 'archive';
                    const sourceBadge = isArchive 
                        ? '<span class="inline-block px-1.5 py-0.5 text-xs rounded bg-indigo-100 text-indigo-700">Archive</span>'
                        : '<span class="inline-block px-1.5 py-0.5 text-xs rounded bg-green-100 text-green-700">Live</span>';

                    html += `
                        <tr class="border-b hover:bg-gray-50">
                            <td class="p-3 font-medium uppercase">${format} ${sourceBadge}</td>
                            <td class="p-3 text-center text-sm">${this.formatDate(data.testDate)}</td>
                            <td class="p-3 text-center">${this.formatNumber(data.iterations || 0)}</td>
                            <td class="p-3 text-center text-sm">${bestPerformance}</td>
                            <td class="p-3 text-center">${avgWithCI}</td>
                            <td class="p-3 text-center">${(data.testDuration || 0).toFixed(1)}s</td>
                            <td class="p-3 text-center text-xs">${originalSource}</td>
                            <td class="p-3 text-center text-xs max-w-[150px] truncate" title="${fileName}">${fileName}</td>
                            <td class="p-3 text-center text-xs">${importedAt}</td>
                            <td class="p-3 text-center ${statusClass}">${status}</td>
                        </tr>
                    `;
                });

                tbody.innerHTML = html;
            }

            renderStatisticalAnalysis() {
                const container = document.getElementById('statisticalAnalysis');
                let html = '';

                Object.entries(this.results).forEach(([format, data]) => {
                    const filteredStats = this.getFilteredStatistics(data);
                    if (Object.keys(filteredStats).length > 0) {
                        const originLabel = data._dataOrigin === 'archive' ? ' (Archive)' : '';
                        html += `
                            <div class="border border-gray-200 rounded-lg p-4">
                                <h3 class="font-semibold text-lg text-gray-800 mb-3">${format.toUpperCase()}${originLabel} ${this.t('summary.stats.format_analysis')}</h3>
                                <div class="grid md:grid-cols-2 gap-4 text-sm">
                        `;

                        Object.entries(filteredStats).forEach(([comparison, stats]) => {
                            const significanceColor = stats.isSignificant ? 'text-green-600' : 'text-red-600';
                            const powerColor = stats.power > 0.8 ? 'text-green-600' : stats.power > 0.5 ? 'text-yellow-600' : 'text-red-600';
                            const sigLabel = stats.isSignificant 
                                ? this.t('summary.stats.sig_' + stats.significanceLevel) 
                                : this.t('summary.stats.not_significant');
                            
                            html += `
                                <div class="bg-gray-50 p-3 rounded">
                                    <div class="font-medium mb-1">${comparison}</div>
                                    <div class="space-y-1">
                                        <div>${this.t('summary.stats.p_value')} ${stats.pValue < 0.001 ? '<0.001' : stats.pValue.toFixed(3)} <span class="${significanceColor}">(${sigLabel})</span></div>
                                        <div>${this.t('summary.stats.power')} <span class="${powerColor}">${stats.power.toFixed(2)}</span></div>
                                        <div>${this.t('summary.stats.effect_size')} ${stats.effectSize.toFixed(2)}</div>
                                    </div>
                                </div>
                            `;
                        });

                        html += `</div></div>`;
                    }
                });

                if (html === '') {
                    html = '<div class="text-gray-500 text-center">' + this.t('summary.stats.no_data') + '</div>';
                }

                container.innerHTML = html;
            }

            renderTestEnvironment() {
                const container = document.getElementById('testEnvironment');
                
                // Use the first available result for environment info
                const firstResult = Object.values(this.results)[0];
                if (!firstResult || !firstResult.testMetadata) {
                    container.innerHTML = '<div class="text-gray-500">' + this.t('summary.env.no_info') + '</div>';
                    return;
                }

                const metadata = firstResult.testMetadata;
                const timerAvail = performance.timeOrigin ? this.t('summary.env.available') : this.t('summary.env.unavailable');
                const memoryAvail = performance.memory ? this.t('summary.env.available') : this.t('summary.env.unavailable');
                const navAvail = performance.navigation ? this.t('summary.env.available') : this.t('summary.env.unavailable');
                container.innerHTML = `
                    <div class="space-y-2">
                        <h4 class="font-medium text-gray-800">${this.t('summary.env.browser_info')}</h4>
                        <div class="text-gray-600">${metadata.userAgent}</div>
                    </div>
                    
                    <div class="space-y-2">
                        <h4 class="font-medium text-gray-800">${this.t('summary.env.perf_metrics')}</h4>
                        <div class="space-y-1 text-gray-600">
                            <div>${this.t('summary.env.timer')} ${timerAvail}</div>
                            <div>${this.t('summary.env.memory')} ${memoryAvail}</div>
                            <div>${this.t('summary.env.navigation')} ${navAvail}</div>
                        </div>
                    </div>
                `;
            }

            exportCsv() {
                if (Object.keys(this.results).length === 0) {
                    alert(this.t('summary.no_export_data'));
                    return;
                }

                const rows = [
                    ['Format', 'Test Started', 'Test Completed', 'Duration (s)', 'Iterations', 'Implementation', 'Rank', 'Average Time (ms)', 'CI Lower', 'CI Upper', 'Std Dev', 'Memory Used Avg (bytes)', 'Sample Size', 'Source Page', 'Data Source', 'Imported']
                ];

                Object.entries(this.results).forEach(([format, data]) => {
                    const exportRanking = this.getFilteredRanking(data);
                    if (exportRanking.length > 0) {
                        const source = data._sourceInfo || {};
                        exportRanking.forEach(result => {
                            // Look up memory for this icon type
                            let memAvg = 'N/A';
                            if (data.results?.[result.iconType]?.memoryUsage?.used?.average != null) {
                                memAvg = data.results[result.iconType].memoryUsage.used.average.toFixed(0);
                            }
                            rows.push([
                                format.toUpperCase(),
                                data.testStartedAt || 'N/A',
                                new Date(data.testDate).toISOString(),
                                (data.testDuration || 0).toFixed(1),
                                data.iterations || 0,
                                result.iconType,
                                result.rank,
                                result.averageTime.toFixed(6),
                                result.confidenceInterval.lower.toFixed(6),
                                result.confidenceInterval.upper.toFixed(6),
                                result.standardDeviation.toFixed(6),
                                memAvg,
                                result.sampleSize,
                                source.originalSource || `${format}.html`,
                                source.fileName || 'Current Data',
                                source.importedAt || 'N/A'
                            ]);
                        });
                    }
                });

                // Append cross-format summary rows
                rows.push([]);
                rows.push(['--- Cross-Format Summary (fastest per format) ---']);
                rows.push(['Format', 'Fastest Icon', 'Avg Time (ms)', 'Memory Used Avg (bytes)']);
                Object.entries(this.results).forEach(([format, data]) => {
                    const ranking = this.getFilteredRanking(data);
                    if (ranking.length === 0) return;
                    const fastest = [...ranking].sort((a, b) => a.averageTime - b.averageTime)[0];
                    let memAvg = 'N/A';
                    if (data.results?.[fastest.iconType]?.memoryUsage?.used?.average != null) {
                        memAvg = data.results[fastest.iconType].memoryUsage.used.average.toFixed(0);
                    }
                    rows.push([format.toUpperCase(), fastest.iconType, fastest.averageTime.toFixed(6), memAvg]);
                });

                const csvContent = rows.map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
                this.downloadFile('icon_performance_results.csv', csvContent, 'text/csv');
            }

            exportJson() {
                if (Object.keys(this.results).length === 0) {
                    alert(this.t('summary.no_export_data'));
                    return;
                }

                // Build comprehensive export with summary, cross-format comparisons, and source data
                const bestFormat = this.getBestPerformingFormat();
                const worstFormat = this.getWorstPerformingFormat();
                const totalIterations = Object.values(this.results).reduce((s, d) => s + (d.iterations || 0), 0);
                const totalDuration = Object.values(this.results).reduce((s, d) => s + (d.testDuration || 0), 0);

                // --- Cross-format comparison ---
                // For each format, find the fastest icon (lowest avg render time).
                // Also collect memory usage for that icon where available.
                const perFormatBest = {};
                Object.entries(this.results).forEach(([format, data]) => {
                    const ranking = this.getFilteredRanking(data);
                    if (ranking.length === 0) return;
                    const sorted = [...ranking].sort((a, b) => a.averageTime - b.averageTime);
                    const fastest = sorted[0];

                    // Locate full result entry for memory data
                    let memoryUsed = null;
                    if (data.results) {
                        const fullEntry = data.results[fastest.iconType];
                        if (fullEntry?.memoryUsage?.used?.average != null) {
                            memoryUsed = fullEntry.memoryUsage.used;
                        }
                    }

                    perFormatBest[format] = {
                        iconType: fastest.iconType,
                        averageTime: fastest.averageTime,
                        confidenceInterval: fastest.confidenceInterval,
                        standardDeviation: fastest.standardDeviation,
                        sampleSize: fastest.sampleSize,
                        memoryUsage: memoryUsed
                    };
                });

                // Build pair-wise comparisons with CSS (the baseline) as reference
                const crossFormatComparisons = [];
                const cssBaseline = perFormatBest['css'];
                if (cssBaseline) {
                    Object.entries(perFormatBest).forEach(([format, entry]) => {
                        if (format === 'css') return;
                        const speedRatio = entry.averageTime / cssBaseline.averageTime;
                        const comparison = {
                            baselineFormat: 'css',
                            baselineIcon: cssBaseline.iconType,
                            baselineAvgTime: cssBaseline.averageTime,
                            comparedFormat: format,
                            comparedIcon: entry.iconType,
                            comparedAvgTime: entry.averageTime,
                            speedRatio: parseFloat(speedRatio.toFixed(4)),
                            note: speedRatio < 1 ? `${format} is ${(1/speedRatio).toFixed(2)}x faster than CSS` :
                                  speedRatio > 1 ? `CSS is ${speedRatio.toFixed(2)}x faster than ${format}` :
                                  'Equivalent performance'
                        };
                        // Memory comparison when both sides have data
                        if (cssBaseline.memoryUsage?.average != null && entry.memoryUsage?.average != null) {
                            comparison.baselineMemory = cssBaseline.memoryUsage;
                            comparison.comparedMemory = entry.memoryUsage;
                            const memRatio = entry.memoryUsage.average / cssBaseline.memoryUsage.average;
                            comparison.memoryRatio = parseFloat(memRatio.toFixed(4));
                        }
                        crossFormatComparisons.push(comparison);
                    });
                }

                // Environment info from first available result
                const firstResult = Object.values(this.results)[0];
                const envInfo = firstResult?.testMetadata || {};

                const exportData = {
                    exportInfo: {
                        exportDate: new Date().toISOString(),
                        exportType: 'Combined Performance Summary',
                        formatsIncluded: Object.keys(this.results),
                        totalFormats: Object.keys(this.results).length
                    },
                    summaryStatistics: {
                        bestFormat: bestFormat,
                        worstFormat: worstFormat,
                        totalIterations: totalIterations,
                        totalTestDurationSeconds: parseFloat(totalDuration.toFixed(2)),
                        perFormatBest: perFormatBest
                    },
                    crossFormatComparisons: crossFormatComparisons,
                    environment: {
                        userAgent: envInfo.userAgent || navigator.userAgent,
                        platform: envInfo.platform || navigator.platform,
                        hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                        memoryApi: !!performance.memory
                    },
                    sourceData: this.results
                };

                const jsonContent = JSON.stringify(exportData, null, 2);
                this.downloadFile('icon_performance_results.json', jsonContent, 'application/json');
            }

            downloadFile(filename, content, contentType) {
                const blob = new Blob([content], { type: contentType });
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);
            }

            clearAllData() {
                if (confirm(this.t('summary.clear_confirm'))) {
                    this.testFormats.forEach(format => {
                        localStorage.removeItem(`iconTestResults_${format}`);
                    });
                    this.results = {};
                    this.render();
                    alert(this.t('summary.clear_success'));
                }
            }
        }

        // Initialize after i18n is ready so translations are available for dynamic content
        let dashboardInstance = null;
        function initDashboard() {
            if (!dashboardInstance) {
                dashboardInstance = new SummaryDashboard();
            } else {
                // Re-render on language change
                dashboardInstance.loadResults();
                dashboardInstance.render();
            }
        }

        document.addEventListener('i18nReady', initDashboard);
        document.addEventListener('languageChanged', function() {
            if (dashboardInstance) {
                dashboardInstance.loadResults();
                dashboardInstance.render();
            }
        });

        // Fallback: if i18n was already ready before this listener was attached
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() {
                if (!dashboardInstance) initDashboard();
            }, 500);
        });
    </script>
</body>
</html>