<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS Implementation Tests - Icon Rendering Performance</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Remix Icons CDN -->
    <link href="https://cdn.jsdelivr.net/npm/remixicon@4.1.0/fonts/remixicon.css" rel="stylesheet">
    
    <style>
        .code-slash-icon {
            position: relative;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: 550;
            color: white;
        }
        
        /* Left bracket < */
        .code-slash-icon::before {
            content: '<';
            position: absolute;
            left: -4px;
            top: 50%;
            transform: translateY(-50%) scaleY(1.2);
            line-height: 1;
        }
        
        /* Right bracket > */
        .code-slash-icon::after {
            content: '>';
            position: absolute;
            right: -3px;
            top: 50%;
            transform: translateY(-50%) scaleY(1.2);
            line-height: 1;
        }
        
        /* Forward slash in the middle */
        .code-slash-icon .slash {
            font-size: 14px;
            font-weight: 550;
            color: white;
            z-index: 1;
            transform: scaleY(1.5);
        }

        /* Minimal CSS implementation - no transforms */
        .simple-icon {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: 550;
            color: white;
            line-height: 1;
            letter-spacing: 1px;
        }

        /* Circular CSS implementation - optimized for circular container */
        .circular-icon {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: 600;
            color: white;
            line-height: 1;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body class="p-8 bg-gray-100">
    <header class="mb-8">
        <a href="index.html" class="text-blue-600 hover:underline text-sm">&larr; Back to Test Suite</a>
        <h1 class="text-3xl font-bold mt-4 mb-2">CSS Implementation Tests</h1>
        <p class="text-gray-600">Testing icon font, pure CSS with transforms, and minimal CSS implementations</p>
    </header>
    
    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4">CSS + Icon Font (Remix Icons)</h2>
        <div class="w-12 h-12 bg-gradient-to-br from-blue-600 to-teal-500 rounded-lg flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
            <i class="ri-code-s-slash-line text-white text-xl"></i>
        </div>
    </div>

    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4">Pure CSS Implementation</h2>
        <div class="w-12 h-12 bg-gradient-to-br from-blue-600 to-teal-500 rounded-lg flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
            <div class="code-slash-icon">
                <span class="slash">/</span>
            </div>
        </div>
    </div>

    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4">Minimal CSS Implementation</h2>
        <div class="w-12 h-12 bg-gradient-to-br from-blue-600 to-teal-500 rounded-lg flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
            <div class="simple-icon">&lt;/&gt;</div>
        </div>
    </div>

    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4">Circular CSS Implementation</h2>
        <div class="w-12 h-12 bg-gradient-to-br from-blue-600 to-teal-500 rounded-full flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
            <div class="circular-icon">&lt;/&gt;</div>
        </div>
    </div>

    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4">Performance Testing Controls</h2>
        <div class="bg-white p-4 rounded border">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Test Type:</label>
                    <select id="testType" class="w-full p-2 border border-gray-300 rounded text-sm">
                        <option value="quick">Quick Test (100 iterations)</option>
                        <option value="standard" selected>Standard Test (2,000 iterations)</option>
                        <option value="stress">High Stress Test (5,000 iterations)</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Batch Size:</label>
                    <input id="batchSize" type="number" value="50" min="1" max="500" class="w-full p-2 border border-gray-300 rounded text-sm">
                    <div class="text-xs text-gray-500 mt-1">Icons per batch (prevents UI freezing)</div>
                </div>
                <div class="flex items-end">
                    <button id="startTest" class="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 transition text-sm font-medium">
                        Start Stress Test
                    </button>
                </div>
            </div>
            
            <div id="testProgress" class="hidden">
                <div class="mb-2">
                    <div class="flex justify-between text-sm">
                        <span id="currentIcon">Testing...</span>
                        <span id="progressText">0%</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-2">
                        <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all" style="width: 0%"></div>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-4 text-xs">
                    <div><strong>Current Iteration:</strong> <span id="currentIteration">0</span></div>
                    <div><strong>Elapsed Time:</strong> <span id="elapsedTime">0s</span></div>
                    <div><strong>Memory Usage:</strong> <span id="memoryUsage">0 MB</span></div>
                    <div><strong>ETA:</strong> <span id="eta">calculating...</span></div>
                </div>
            </div>

            <div class="mt-4">
                <button id="stopTest" class="bg-red-600 text-white px-4 py-1 rounded hover:bg-red-700 transition text-sm hidden">
                    Stop Test
                </button>
                <button id="clearResults" class="bg-gray-600 text-white px-4 py-1 rounded hover:bg-gray-700 transition text-sm ml-2">
                    Clear Results
                </button>
            </div>
        </div>
    </div>

    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4">Test Results</h2>
        <div id="results" class="text-sm text-gray-700 space-y-2">
            <div class="text-gray-500">No tests run yet. Click "Start Stress Test" to begin performance analysis.</div>
        </div>
    </div>

    <script>
        class StressTestManager {
            constructor() {
                this.isRunning = false;
                this.shouldStop = false;
                this.currentTest = null;
                this.results = {};
                this.startTime = 0;
                this.totalIterations = 0;
                this.completedIterations = 0;
                this.batchSize = 50;
                
                this.iconConfigs = [
                    {
                        name: 'Remix Icon (Font)',
                        selector: '.ri-code-s-slash-line',
                        containerSelector: '.ri-code-s-slash-line',
                        hasNetworkOverhead: true
                    },
                    {
                        name: 'Pure CSS Icon',
                        selector: '.code-slash-icon',
                        containerSelector: '.code-slash-icon',
                        hasNetworkOverhead: false
                    },
                    {
                        name: 'Minimal CSS Icon',
                        selector: '.simple-icon',
                        containerSelector: '.simple-icon',
                        hasNetworkOverhead: false
                    },
                    {
                        name: 'Circular CSS Icon',
                        selector: '.circular-icon',
                        containerSelector: '.circular-icon',
                        hasNetworkOverhead: false
                    }
                ];
                
                this.setupEventListeners();
                this.updateMemoryDisplay();
            }

            setupEventListeners() {
                document.getElementById('startTest').addEventListener('click', () => this.startStressTest());
                document.getElementById('stopTest').addEventListener('click', () => this.stopTest());
                document.getElementById('clearResults').addEventListener('click', () => this.clearResults());
                
                // Update memory display every 2 seconds
                setInterval(() => this.updateMemoryDisplay(), 2000);
            }

            updateMemoryDisplay() {
                if (performance.memory && document.getElementById('memoryUsage')) {
                    const memoryMB = (performance.memory.usedJSHeapSize / (1024 * 1024)).toFixed(1);
                    document.getElementById('memoryUsage').textContent = `${memoryMB} MB`;
                }
            }

            async startStressTest() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.shouldStop = false;
                this.startTime = performance.now();
                this.results = {};
                this.completedIterations = 0;
                
                // Get test parameters
                const testType = document.getElementById('testType').value;
                const iterationMap = { quick: 100, standard: 2000, stress: 5000 };
                this.totalIterations = iterationMap[testType] * this.iconConfigs.length;
                this.batchSize = parseInt(document.getElementById('batchSize').value) || 50;
                
                // Update UI
                this.showProgress(true);
                this.updateProgress('Initializing stress test...', 0);
                
                try {
                    // Run test for each icon configuration
                    for (const config of this.iconConfigs) {
                        if (this.shouldStop) break;
                        
                        await this.testIconConfiguration(config, iterationMap[testType]);
                    }
                    
                    if (!this.shouldStop) {
                        await this.displayAggregatedResults();
                    }
                } catch (error) {
                    console.error('Stress test error:', error);
                    this.displayError(error.message);
                } finally {
                    this.isRunning = false;
                    this.showProgress(false);
                }
            }

            async testIconConfiguration(config, iterations) {
                this.updateProgress(`Testing ${config.name}...`, this.completedIterations / this.totalIterations * 100);
                
                const measurements = {
                    renderTimes: [],
                    memoryUsage: [],
                    elementMetrics: null,
                    networkMetrics: null
                };

                // Measure network overhead for font-based icons (once)
                if (config.hasNetworkOverhead && !measurements.networkMetrics) {
                    measurements.networkMetrics = await this.measureNetworkOverhead();
                }

                // Run iterations in batches
                for (let i = 0; i < iterations; i += this.batchSize) {
                    if (this.shouldStop) break;
                    
                    const batchEnd = Math.min(i + this.batchSize, iterations);
                    await this.processBatch(config, i, batchEnd, measurements);
                    
                    this.completedIterations += (batchEnd - i);
                    const progress = (this.completedIterations / this.totalIterations) * 100;
                    this.updateProgress(`${config.name}: ${batchEnd}/${iterations}`, progress);
                    
                    // Memory cleanup between batches
                    if (i % (this.batchSize * 5) === 0 && typeof window.gc === 'function') {
                        window.gc();
                    }
                    
                    // Small delay to prevent UI freezing
                    await this.delay(10);
                }

                // Store aggregated results
                this.results[config.name] = this.calculateStatistics(measurements);
            }

            async processBatch(config, startIndex, endIndex, measurements) {
                const element = document.querySelector(config.selector);
                if (!element) {
                    throw new Error(`Element not found: ${config.selector}`);
                }

                // Measure element metrics once per configuration
                if (!measurements.elementMetrics) {
                    measurements.elementMetrics = this.measureElementMetrics(element);
                }

                // Run batch iterations
                for (let i = startIndex; i < endIndex; i++) {
                    const startMemory = this.getMemoryUsage();
                    const renderTime = await this.measureSingleRender(element);
                    const endMemory = this.getMemoryUsage();
                    
                    measurements.renderTimes.push(renderTime);
                    measurements.memoryUsage.push({
                        used: endMemory.used - startMemory.used,
                        total: endMemory.total
                    });
                }
            }

            async measureSingleRender(element) {
                return new Promise((resolve) => {
                    const start = performance.now();
                    
                    // Force a style recalculation by modifying and restoring a property
                    const originalDisplay = element.style.display;
                    element.style.display = 'none';
                    element.offsetHeight; // Force reflow
                    element.style.display = originalDisplay;
                    
                    requestAnimationFrame(() => {
                        const end = performance.now();
                        resolve(end - start);
                    });
                });
            }

            measureElementMetrics(element) {
                const rect = element.getBoundingClientRect();
                const computedStyle = window.getComputedStyle(element);
                
                return {
                    width: rect.width,
                    height: rect.height,
                    area: rect.width * rect.height,
                    childNodes: element.childNodes ? element.childNodes.length : 0,
                    cssRules: computedStyle.length,
                    computedStyles: {
                        fontSize: computedStyle.fontSize,
                        fontFamily: computedStyle.fontFamily,
                        color: computedStyle.color
                    }
                };
            }

            async measureNetworkOverhead() {
                const startTime = performance.now();
                const networkRequests = [];
                
                if ('PerformanceObserver' in window) {
                    const entries = performance.getEntriesByType('resource');
                    entries.forEach(entry => {
                        if (entry.name.includes('remixicon') || entry.name.includes('remix')) {
                            networkRequests.push({
                                url: entry.name,
                                duration: entry.duration,
                                size: entry.transferSize || entry.decodedBodySize || 0,
                                startTime: entry.startTime
                            });
                        }
                    });
                }

                return {
                    fontLoadTime: performance.now() - startTime,
                    networkRequests: networkRequests,
                    totalFontSize: networkRequests.reduce((sum, req) => sum + req.size, 0),
                    fontStatus: document.fonts ? document.fonts.status : 'unknown'
                };
            }

            calculateStatistics(measurements) {
                const stats = {
                    renderTime: this.calculateArrayStats(measurements.renderTimes),
                    memoryUsage: {
                        used: this.calculateArrayStats(measurements.memoryUsage.map(m => m.used)),
                        total: measurements.memoryUsage.length > 0 ? measurements.memoryUsage[measurements.memoryUsage.length - 1].total : 0
                    },
                    elementMetrics: measurements.elementMetrics,
                    networkMetrics: measurements.networkMetrics,
                    sampleSize: measurements.renderTimes.length
                };
                
                return stats;
            }

            calculateArrayStats(values) {
                if (values.length === 0) return { min: 0, max: 0, average: 0, stdDev: 0, median: 0, confidenceInterval: {lower: 0, upper: 0}, standardError: 0 };
                
                const sorted = [...values].sort((a, b) => a - b);
                const sum = values.reduce((a, b) => a + b, 0);
                const average = sum / values.length;
                const n = values.length;
                
                const variance = values.reduce((acc, val) => acc + Math.pow(val - average, 2), 0) / (n - 1);
                const stdDev = Math.sqrt(variance);
                const standardError = stdDev / Math.sqrt(n);
                
                // 95% Confidence Interval (t-distribution, df = n-1)
                const tCritical = this.getTCritical(n - 1, 0.05); // 95% confidence
                const marginOfError = tCritical * standardError;
                
                const median = sorted.length % 2 === 0 
                    ? (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2
                    : sorted[Math.floor(sorted.length / 2)];
                
                return {
                    min: sorted[0],
                    max: sorted[sorted.length - 1],
                    average: average,
                    stdDev: stdDev,
                    median: median,
                    standardError: standardError,
                    confidenceInterval: {
                        lower: average - marginOfError,
                        upper: average + marginOfError
                    },
                    sampleSize: n
                };
            }

            // Get t-critical value for confidence intervals
            getTCritical(df, alpha) {
                // Simplified t-table for 95% confidence (alpha = 0.05)
                const tTable = {
                    1: 12.706, 5: 2.571, 10: 2.228, 20: 2.086, 30: 2.042, 
                    40: 2.021, 50: 2.009, 60: 2.000, 100: 1.984, 500: 1.965, 
                    1000: 1.962, Infinity: 1.960
                };
                
                // Find closest match
                const keys = Object.keys(tTable).map(k => k === 'Infinity' ? Infinity : parseInt(k));
                for (let i = 0; i < keys.length; i++) {
                    if (df <= keys[i]) {
                        return tTable[keys[i]];
                    }
                }
                return 1.960; // Default to z-score for large samples
            }

            // Calculate statistical power for detecting differences
            calculateStatisticalPower(group1Stats, group2Stats) {
                const pooledStdDev = Math.sqrt(
                    ((group1Stats.sampleSize - 1) * Math.pow(group1Stats.stdDev, 2) + 
                     (group2Stats.sampleSize - 1) * Math.pow(group2Stats.stdDev, 2)) /
                    (group1Stats.sampleSize + group2Stats.sampleSize - 2)
                );
                
                const effectSize = Math.abs(group1Stats.average - group2Stats.average) / pooledStdDev;
                const harmonicMean = 2 * group1Stats.sampleSize * group2Stats.sampleSize / 
                                   (group1Stats.sampleSize + group2Stats.sampleSize);
                
                // Simplified power calculation (approximate)
                const delta = effectSize * Math.sqrt(harmonicMean / 2);
                const power = this.normalCDF(delta - 1.96) + (1 - this.normalCDF(delta + 1.96));
                
                return Math.max(0, Math.min(0.999, power));
            }

            // Calculate p-value using Welch's t-test (unequal variances)
            calculatePValue(group1Stats, group2Stats) {
                const n1 = group1Stats.sampleSize;
                const n2 = group2Stats.sampleSize;
                const mean1 = group1Stats.average;
                const mean2 = group2Stats.average;
                const var1 = Math.pow(group1Stats.stdDev, 2);
                const var2 = Math.pow(group2Stats.stdDev, 2);
                
                // Welch's t-test
                const tStat = (mean1 - mean2) / Math.sqrt(var1/n1 + var2/n2);
                
                // Degrees of freedom (Welch-Satterthwaite equation)
                const df = Math.pow(var1/n1 + var2/n2, 2) / 
                          (Math.pow(var1/n1, 2)/(n1-1) + Math.pow(var2/n2, 2)/(n2-1));
                
                // Two-tailed p-value (approximate)
                const pValue = 2 * (1 - this.tCDF(Math.abs(tStat), df));
                
                return Math.max(0.001, Math.min(0.999, pValue));
            }

            // Approximate normal CDF
            normalCDF(x) {
                return 0.5 * (1 + this.erf(x / Math.sqrt(2)));
            }

            // Approximate error function
            erf(x) {
                const a1 =  0.254829592;
                const a2 = -0.284496736;
                const a3 =  1.421413741;
                const a4 = -1.453152027;
                const a5 =  1.061405429;
                const p  =  0.3275911;
                
                const sign = x >= 0 ? 1 : -1;
                x = Math.abs(x);
                
                const t = 1.0 / (1.0 + p * x);
                const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
                
                return sign * y;
            }

            // Approximate t-distribution CDF
            tCDF(t, df) {
                if (df >= 100) {
                    return this.normalCDF(t); // Use normal approximation for large df
                }
                
                // Simplified approximation
                const x = t / Math.sqrt(df);
                return 0.5 + 0.5 * this.erf(x / Math.sqrt(2));
            }

            async displayAggregatedResults() {
                const resultsDiv = document.getElementById('results');
                const testDuration = (performance.now() - this.startTime) / 1000;
                
                let html = `
                    <div class="bg-green-50 border border-green-200 p-3 rounded mb-4">
                        <h3 class="font-semibold text-green-800">Stress Test Complete!</h3>
                        <div class="text-sm text-green-700 mt-1">
                            Total Duration: ${testDuration.toFixed(1)}s | 
                            Total Iterations: ${this.completedIterations.toLocaleString()} | 
                            Average Speed: ${(this.completedIterations / testDuration).toFixed(1)} iterations/sec
                        </div>
                    </div>
                `;

                // Performance comparison table
                html += '<div class="bg-white rounded border overflow-hidden mb-4">';
                html += '<h3 class="font-semibold p-3 bg-gray-50 border-b">Performance Statistics & Statistical Analysis</h3>';
                html += '<div class="overflow-x-auto">';
                html += '<table class="w-full text-xs">';
                html += '<thead><tr class="bg-gray-50 border-b">';
                html += '<th class="p-2 text-left">Icon Type</th>';
                html += '<th class="p-2 text-center">Avg ± 95% CI (ms)</th>';
                html += '<th class="p-2 text-center">Min/Max (ms)</th>';
                html += '<th class="p-2 text-center">Std Dev</th>';
                html += '<th class="p-2 text-center">Sample Size</th>';
                html += '</tr></thead><tbody>';

                // Sort results by average render time
                const sortedResults = Object.entries(this.results).sort((a, b) => 
                    a[1].renderTime.average - b[1].renderTime.average
                );

                for (const [iconType, data] of sortedResults) {
                    const isRemixIcon = iconType.includes('Font');
                    const rowClass = isRemixIcon ? 'bg-blue-25' : '';
                    const ci = data.renderTime.confidenceInterval;
                    
                    html += `<tr class="${rowClass} border-b">`;
                    html += `<td class="p-2 font-medium">${iconType}</td>`;
                    html += `<td class="p-2 text-center">${data.renderTime.average.toFixed(3)} ± [${ci.lower.toFixed(3)}, ${ci.upper.toFixed(3)}]</td>`;
                    html += `<td class="p-2 text-center">${data.renderTime.min.toFixed(3)} - ${data.renderTime.max.toFixed(3)}</td>`;
                    html += `<td class="p-2 text-center">${data.renderTime.stdDev.toFixed(3)}</td>`;
                    html += `<td class="p-2 text-center">${data.sampleSize.toLocaleString()}</td>`;
                    html += '</tr>';
                }

                html += '</tbody></table></div></div>';

                // Statistical Analysis Table
                html += this.generateStatisticalAnalysisTable(sortedResults);

                // Detailed analysis
                html += this.generateDetailedAnalysis(sortedResults, testDuration);

                resultsDiv.innerHTML = html;
            }

            generateStatisticalAnalysisTable(sortedResults) {
                if (sortedResults.length < 2) return '';
                
                let html = '<div class="bg-white rounded border overflow-hidden mb-4">';
                html += '<h3 class="font-semibold p-3 bg-gray-50 border-b">Statistical Significance Analysis</h3>';
                html += '<div class="overflow-x-auto">';
                html += '<table class="w-full text-xs">';
                html += '<thead><tr class="bg-gray-50 border-b">';
                html += '<th class="p-2 text-left">Comparison</th>';
                html += '<th class="p-2 text-center">P-Value</th>';
                html += '<th class="p-2 text-center">Significance</th>';
                html += '<th class="p-2 text-center">Statistical Power</th>';
                html += '<th class="p-2 text-center">Effect Size</th>';
                html += '<th class="p-2 text-center">Confidence</th>';
                html += '</tr></thead><tbody>';

                // Compare each method against the fastest (baseline)
                const baseline = sortedResults[0];
                const baselineStats = baseline[1].renderTime;
                
                for (let i = 1; i < sortedResults.length; i++) {
                    const comparison = sortedResults[i];
                    const comparisonStats = comparison[1].renderTime;
                    
                    const pValue = this.calculatePValue(baselineStats, comparisonStats);
                    const power = this.calculateStatisticalPower(baselineStats, comparisonStats);
                    const effectSize = Math.abs(baselineStats.average - comparisonStats.average) / 
                                     Math.sqrt((Math.pow(baselineStats.stdDev, 2) + Math.pow(comparisonStats.stdDev, 2)) / 2);
                    
                    const isSignificant = pValue < 0.05;
                    const significanceText = isSignificant ? 
                        (pValue < 0.001 ? 'Highly Significant***' : pValue < 0.01 ? 'Very Significant**' : 'Significant*') : 
                        'Not Significant';
                    const significanceColor = isSignificant ? 'text-green-600' : 'text-red-600';
                    
                    const powerText = power > 0.8 ? 'High' : power > 0.5 ? 'Medium' : 'Low';
                    const powerColor = power > 0.8 ? 'text-green-600' : power > 0.5 ? 'text-yellow-600' : 'text-red-600';
                    
                    const effectSizeText = effectSize > 0.8 ? 'Large' : effectSize > 0.5 ? 'Medium' : 'Small';
                    
                    html += `<tr class="border-b">`;
                    html += `<td class="p-2 font-medium">${comparison[0]} vs ${baseline[0]}</td>`;
                    html += `<td class="p-2 text-center">${pValue < 0.001 ? '<0.001' : pValue.toFixed(3)}</td>`;
                    html += `<td class="p-2 text-center ${significanceColor}">${significanceText}</td>`;
                    html += `<td class="p-2 text-center ${powerColor}">${powerText} (${power.toFixed(2)})</td>`;
                    html += `<td class="p-2 text-center">${effectSizeText} (${effectSize.toFixed(2)})</td>`;
                    html += `<td class="p-2 text-center">${!isSignificant ? 'Low' : power > 0.8 ? 'High' : 'Medium'}</td>`;
                    html += '</tr>';
                }

                html += '</tbody></table></div>';
                
                // Statistical interpretation
                html += '<div class="p-3 bg-gray-50 text-xs">';
                html += '<div class="mb-2"><strong>Statistical Interpretation:</strong></div>';
                html += '<div class="grid grid-cols-1 md:grid-cols-2 gap-2">';
                html += '<div>• <strong>P-Value < 0.05:</strong> Statistically significant difference</div>';
                html += '<div>• <strong>Power > 0.8:</strong> High confidence in detecting real differences</div>';
                html += '<div>• <strong>Effect Size > 0.5:</strong> Meaningful practical difference</div>';
                html += '<div>• <strong>95% CI:</strong> True average lies within this range 95% of the time</div>';
                html += '</div></div>';
                
                html += '</div>';
                return html;
            }

            generateDetailedAnalysis(sortedResults, testDuration) {
                let html = '<div class="space-y-4">';
                
                // Performance ranking
                html += '<div class="bg-white p-4 rounded border">';
                html += '<h4 class="font-semibold mb-3">Performance Ranking</h4>';
                
                sortedResults.forEach(([iconType, data], index) => {
                    const rank = index + 1;
                    const rankColor = rank === 1 ? 'text-green-600' : rank === sortedResults.length ? 'text-red-600' : 'text-gray-600';
                    html += `<div class="flex justify-between items-center py-1">`;
                    html += `<span class="${rankColor} font-medium">#${rank} ${iconType}</span>`;
                    html += `<span class="text-sm">${data.renderTime.average.toFixed(3)}ms avg</span>`;
                    html += '</div>';
                });
                html += '</div>';

                // Network overhead analysis
                const fontIcon = sortedResults.find(([name]) => name.includes('Font'));
                if (fontIcon && fontIcon[1].networkMetrics) {
                    const networkData = fontIcon[1].networkMetrics;
                    html += '<div class="bg-yellow-50 border border-yellow-200 p-4 rounded">';
                    html += '<h4 class="font-semibold text-yellow-800 mb-3">Network Overhead (Font-based Icons)</h4>';
                    html += '<div class="grid grid-cols-2 gap-4 text-sm">';
                    html += `<div><strong>Font Load Time:</strong> ${networkData.fontLoadTime.toFixed(2)}ms</div>`;
                    html += `<div><strong>Font File Size:</strong> ${this.formatMemory(networkData.totalFontSize)}</div>`;
                    html += `<div><strong>Network Requests:</strong> ${networkData.networkRequests.length}</div>`;
                    html += `<div><strong>Font Status:</strong> ${networkData.fontStatus}</div>`;
                    html += '</div></div>';
                }

                // Speed comparison with statistical confidence
                if (sortedResults.length > 1) {
                    const fastest = sortedResults[0][1].renderTime;
                    const slowest = sortedResults[sortedResults.length - 1][1].renderTime;
                    const speedDiff = (slowest.average / fastest.average).toFixed(1);
                    const pValue = this.calculatePValue(fastest, slowest);
                    const power = this.calculateStatisticalPower(fastest, slowest);
                    
                    html += '<div class="bg-blue-50 border border-blue-200 p-4 rounded">';
                    html += '<h4 class="font-semibold text-blue-800 mb-3">Statistical Performance Analysis</h4>';
                    html += '<div class="grid grid-cols-2 gap-4 text-sm">';
                    html += `<div><strong>Speed Difference:</strong> ${speedDiff}x faster</div>`;
                    html += `<div><strong>Statistical Significance:</strong> p = ${pValue < 0.001 ? '<0.001' : pValue.toFixed(3)}</div>`;
                    html += `<div><strong>Statistical Power:</strong> ${power.toFixed(2)} (${power > 0.8 ? 'High' : power > 0.5 ? 'Medium' : 'Low'})</div>`;
                    html += `<div><strong>Total Test Time:</strong> ${testDuration.toFixed(1)}s</div>`;
                    html += `<div><strong>Fastest Method:</strong> ${sortedResults[0][0]}</div>`;
                    html += `<div><strong>Slowest Method:</strong> ${sortedResults[sortedResults.length - 1][0]}</div>`;
                    
                    // Add confidence interval comparison
                    const fastestCI = fastest.confidenceInterval;
                    const slowestCI = slowest.confidenceInterval;
                    html += `<div class="col-span-2 border-t pt-2 mt-2">`;
                    html += `<div><strong>95% Confidence Intervals:</strong></div>`;
                    html += `<div class="ml-2">Fastest: ${fastestCI.lower.toFixed(3)} - ${fastestCI.upper.toFixed(3)} ms</div>`;
                    html += `<div class="ml-2">Slowest: ${slowestCI.lower.toFixed(3)} - ${slowestCI.upper.toFixed(3)} ms</div>`;
                    html += `<div class="ml-2 mt-1 ${fastestCI.upper < slowestCI.lower ? 'text-green-600' : 'text-orange-600'}">`;
                    html += `Confidence intervals ${fastestCI.upper < slowestCI.lower ? 'do not overlap' : 'overlap'} `;
                    html += `(${fastestCI.upper < slowestCI.lower ? 'strong evidence of difference' : 'some uncertainty in ranking'})</div>`;
                    html += `</div>`;
                    
                    html += '</div></div>';
                }

                html += '</div>';
                return html;
            }

            formatMemory(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            getMemoryUsage() {
                if (performance.memory) {
                    return {
                        used: performance.memory.usedJSHeapSize,
                        total: performance.memory.totalJSHeapSize,
                        limit: performance.memory.jsHeapSizeLimit
                    };
                }
                return { used: 0, total: 0, limit: 0 };
            }

            updateProgress(message, percentage) {
                if (document.getElementById('currentIcon')) {
                    document.getElementById('currentIcon').textContent = message;
                }
                if (document.getElementById('progressText')) {
                    document.getElementById('progressText').textContent = `${percentage.toFixed(1)}%`;
                }
                if (document.getElementById('progressBar')) {
                    document.getElementById('progressBar').style.width = `${percentage}%`;
                }
                if (document.getElementById('currentIteration')) {
                    document.getElementById('currentIteration').textContent = this.completedIterations.toLocaleString();
                }
                if (document.getElementById('elapsedTime')) {
                    const elapsed = (performance.now() - this.startTime) / 1000;
                    document.getElementById('elapsedTime').textContent = `${elapsed.toFixed(1)}s`;
                }
                if (document.getElementById('eta') && percentage > 0) {
                    const elapsed = (performance.now() - this.startTime) / 1000;
                    const totalEstimated = (elapsed / percentage) * 100;
                    const remaining = totalEstimated - elapsed;
                    document.getElementById('eta').textContent = `${remaining.toFixed(0)}s`;
                }
            }

            showProgress(show) {
                const progressDiv = document.getElementById('testProgress');
                const startBtn = document.getElementById('startTest');
                const stopBtn = document.getElementById('stopTest');
                
                if (show) {
                    progressDiv.classList.remove('hidden');
                    startBtn.disabled = true;
                    startBtn.textContent = 'Testing...';
                    startBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    stopBtn.classList.remove('hidden');
                } else {
                    progressDiv.classList.add('hidden');
                    startBtn.disabled = false;
                    startBtn.textContent = 'Start Stress Test';
                    startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    stopBtn.classList.add('hidden');
                }
            }

            stopTest() {
                this.shouldStop = true;
                this.isRunning = false;
                this.showProgress(false);
                
                const resultsDiv = document.getElementById('results');
                resultsDiv.innerHTML = '<div class="bg-yellow-100 border border-yellow-400 text-yellow-700 px-4 py-3 rounded">Test stopped by user.</div>';
            }

            clearResults() {
                document.getElementById('results').innerHTML = '<div class="text-gray-500">No tests run yet. Click "Start Stress Test" to begin performance analysis.</div>';
            }

            displayError(message) {
                const resultsDiv = document.getElementById('results');
                resultsDiv.innerHTML = `<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">Error: ${message}</div>`;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize the stress test manager when DOM is ready
        let stressTestManager;
        document.addEventListener('DOMContentLoaded', function() {
            stressTestManager = new StressTestManager();
        });
    </script>
</body>
</html>