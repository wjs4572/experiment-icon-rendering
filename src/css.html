<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS Implementation Tests - Icon Rendering Performance</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Remix Icons CDN -->
    <link href="https://cdn.jsdelivr.net/npm/remixicon@4.1.0/fonts/remixicon.css" rel="stylesheet">
    
    <style>
        .code-slash-icon {
            position: relative;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: 550;
            color: white;
        }
        
        /* Left bracket < */
        .code-slash-icon::before {
            content: '<';
            position: absolute;
            left: -4px;
            top: 50%;
            transform: translateY(-50%) scaleY(1.2);
            line-height: 1;
        }
        
        /* Right bracket > */
        .code-slash-icon::after {
            content: '>';
            position: absolute;
            right: -3px;
            top: 50%;
            transform: translateY(-50%) scaleY(1.2);
            line-height: 1;
        }
        
        /* Forward slash in the middle */
        .code-slash-icon .slash {
            font-size: 14px;
            font-weight: 550;
            color: white;
            z-index: 1;
            transform: scaleY(1.5);
        }

        /* Minimal CSS implementation - no transforms */
        .simple-icon {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: 550;
            color: white;
            line-height: 1;
            letter-spacing: 1px;
        }

        /* Circular CSS implementation - optimized for circular container */
        .circular-icon {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: 600;
            color: white;
            line-height: 1;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body class="p-8 bg-gray-100">
    <header class="mb-8">
        <a href="index.html" class="text-blue-600 hover:underline text-sm">&larr; Back to Test Suite</a>
        <h1 class="text-3xl font-bold mt-4 mb-2">CSS Implementation Tests</h1>
        <p class="text-gray-600">Testing icon font, pure CSS with transforms, and minimal CSS implementations</p>
    </header>
    
    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4">CSS + Icon Font (Remix Icons)</h2>
        <div class="w-12 h-12 bg-gradient-to-br from-blue-600 to-teal-500 rounded-lg flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
            <i class="ri-code-s-slash-line text-white text-xl"></i>
        </div>
    </div>

    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4">Pure CSS Implementation</h2>
        <div class="w-12 h-12 bg-gradient-to-br from-blue-600 to-teal-500 rounded-lg flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
            <div class="code-slash-icon">
                <span class="slash">/</span>
            </div>
        </div>
    </div>

    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4">Minimal CSS Implementation</h2>
        <div class="w-12 h-12 bg-gradient-to-br from-blue-600 to-teal-500 rounded-lg flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
            <div class="simple-icon">&lt;/&gt;</div>
        </div>
    </div>

    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4">Circular CSS Implementation</h2>
        <div class="w-12 h-12 bg-gradient-to-br from-blue-600 to-teal-500 rounded-full flex items-center justify-center mb-6 group-hover:scale-110 transition-transform">
            <div class="circular-icon">&lt;/&gt;</div>
        </div>
    </div>

    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4">Performance Testing Controls</h2>
        <div class="bg-white p-4 rounded border">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Test Type:</label>
                    <select id="testType" class="w-full p-2 border border-gray-300 rounded text-sm">
                        <option value="quick">Quick Test (100 iterations)</option>
                        <option value="standard">Standard Test (1,000 iterations)</option>
                        <option value="stress" selected>Stress Test (10,000 iterations)</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Batch Size:</label>
                    <input id="batchSize" type="number" value="50" min="1" max="500" class="w-full p-2 border border-gray-300 rounded text-sm">
                    <div class="text-xs text-gray-500 mt-1">Icons per batch (prevents UI freezing)</div>
                </div>
                <div class="flex items-end">
                    <button id="startTest" class="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 transition text-sm font-medium">
                        Start Stress Test
                    </button>
                </div>
            </div>
            
            <div id="testProgress" class="hidden">
                <div class="mb-2">
                    <div class="flex justify-between text-sm">
                        <span id="currentIcon">Testing...</span>
                        <span id="progressText">0%</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-2">
                        <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all" style="width: 0%"></div>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-4 text-xs">
                    <div><strong>Current Iteration:</strong> <span id="currentIteration">0</span></div>
                    <div><strong>Elapsed Time:</strong> <span id="elapsedTime">0s</span></div>
                    <div><strong>Memory Usage:</strong> <span id="memoryUsage">0 MB</span></div>
                    <div><strong>ETA:</strong> <span id="eta">calculating...</span></div>
                </div>
            </div>

            <div class="mt-4">
                <button id="stopTest" class="bg-red-600 text-white px-4 py-1 rounded hover:bg-red-700 transition text-sm hidden">
                    Stop Test
                </button>
                <button id="clearResults" class="bg-gray-600 text-white px-4 py-1 rounded hover:bg-gray-700 transition text-sm ml-2">
                    Clear Results
                </button>
            </div>
        </div>
    </div>

    <div class="mb-8">
        <h2 class="text-xl font-semibold mb-4">Test Results</h2>
        <div id="results" class="text-sm text-gray-700 space-y-2">
            <div class="text-gray-500">No tests run yet. Click "Start Stress Test" to begin performance analysis.</div>
        </div>
    </div>

    <script>
        class StressTestManager {
            constructor() {
                this.isRunning = false;
                this.shouldStop = false;
                this.currentTest = null;
                this.results = {};
                this.startTime = 0;
                this.totalIterations = 0;
                this.completedIterations = 0;
                this.batchSize = 50;
                
                this.iconConfigs = [
                    {
                        name: 'Remix Icon (Font)',
                        selector: '.ri-code-s-slash-line',
                        containerSelector: '.ri-code-s-slash-line',
                        hasNetworkOverhead: true
                    },
                    {
                        name: 'Pure CSS Icon',
                        selector: '.code-slash-icon',
                        containerSelector: '.code-slash-icon',
                        hasNetworkOverhead: false
                    },
                    {
                        name: 'Minimal CSS Icon',
                        selector: '.simple-icon',
                        containerSelector: '.simple-icon',
                        hasNetworkOverhead: false
                    },
                    {
                        name: 'Circular CSS Icon',
                        selector: '.circular-icon',
                        containerSelector: '.circular-icon',
                        hasNetworkOverhead: false
                    }
                ];
                
                this.setupEventListeners();
                this.updateMemoryDisplay();
            }

            setupEventListeners() {
                document.getElementById('startTest').addEventListener('click', () => this.startStressTest());
                document.getElementById('stopTest').addEventListener('click', () => this.stopTest());
                document.getElementById('clearResults').addEventListener('click', () => this.clearResults());
                
                // Update memory display every 2 seconds
                setInterval(() => this.updateMemoryDisplay(), 2000);
            }

            updateMemoryDisplay() {
                if (performance.memory && document.getElementById('memoryUsage')) {
                    const memoryMB = (performance.memory.usedJSHeapSize / (1024 * 1024)).toFixed(1);
                    document.getElementById('memoryUsage').textContent = `${memoryMB} MB`;
                }
            }

            async startStressTest() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.shouldStop = false;
                this.startTime = performance.now();
                this.results = {};
                this.completedIterations = 0;
                
                // Get test parameters
                const testType = document.getElementById('testType').value;
                const iterationMap = { quick: 100, standard: 1000, stress: 10000 };
                this.totalIterations = iterationMap[testType] * this.iconConfigs.length;
                this.batchSize = parseInt(document.getElementById('batchSize').value) || 50;
                
                // Update UI
                this.showProgress(true);
                this.updateProgress('Initializing stress test...', 0);
                
                try {
                    // Run test for each icon configuration
                    for (const config of this.iconConfigs) {
                        if (this.shouldStop) break;
                        
                        await this.testIconConfiguration(config, iterationMap[testType]);
                    }
                    
                    if (!this.shouldStop) {
                        await this.displayAggregatedResults();
                    }
                } catch (error) {
                    console.error('Stress test error:', error);
                    this.displayError(error.message);
                } finally {
                    this.isRunning = false;
                    this.showProgress(false);
                }
            }

            async testIconConfiguration(config, iterations) {
                this.updateProgress(`Testing ${config.name}...`, this.completedIterations / this.totalIterations * 100);
                
                const measurements = {
                    renderTimes: [],
                    memoryUsage: [],
                    elementMetrics: null,
                    networkMetrics: null
                };

                // Measure network overhead for font-based icons (once)
                if (config.hasNetworkOverhead && !measurements.networkMetrics) {
                    measurements.networkMetrics = await this.measureNetworkOverhead();
                }

                // Run iterations in batches
                for (let i = 0; i < iterations; i += this.batchSize) {
                    if (this.shouldStop) break;
                    
                    const batchEnd = Math.min(i + this.batchSize, iterations);
                    await this.processBatch(config, i, batchEnd, measurements);
                    
                    this.completedIterations += (batchEnd - i);
                    const progress = (this.completedIterations / this.totalIterations) * 100;
                    this.updateProgress(`${config.name}: ${batchEnd}/${iterations}`, progress);
                    
                    // Memory cleanup between batches
                    if (i % (this.batchSize * 5) === 0 && typeof window.gc === 'function') {
                        window.gc();
                    }
                    
                    // Small delay to prevent UI freezing
                    await this.delay(10);
                }

                // Store aggregated results
                this.results[config.name] = this.calculateStatistics(measurements);
            }

            async processBatch(config, startIndex, endIndex, measurements) {
                const element = document.querySelector(config.selector);
                if (!element) {
                    throw new Error(`Element not found: ${config.selector}`);
                }

                // Measure element metrics once per configuration
                if (!measurements.elementMetrics) {
                    measurements.elementMetrics = this.measureElementMetrics(element);
                }

                // Run batch iterations
                for (let i = startIndex; i < endIndex; i++) {
                    const startMemory = this.getMemoryUsage();
                    const renderTime = await this.measureSingleRender(element);
                    const endMemory = this.getMemoryUsage();
                    
                    measurements.renderTimes.push(renderTime);
                    measurements.memoryUsage.push({
                        used: endMemory.used - startMemory.used,
                        total: endMemory.total
                    });
                }
            }

            async measureSingleRender(element) {
                return new Promise((resolve) => {
                    const start = performance.now();
                    
                    // Force a style recalculation by modifying and restoring a property
                    const originalDisplay = element.style.display;
                    element.style.display = 'none';
                    element.offsetHeight; // Force reflow
                    element.style.display = originalDisplay;
                    
                    requestAnimationFrame(() => {
                        const end = performance.now();
                        resolve(end - start);
                    });
                });
            }

            measureElementMetrics(element) {
                const rect = element.getBoundingClientRect();
                const computedStyle = window.getComputedStyle(element);
                
                return {
                    width: rect.width,
                    height: rect.height,
                    area: rect.width * rect.height,
                    childNodes: element.childNodes ? element.childNodes.length : 0,
                    cssRules: computedStyle.length,
                    computedStyles: {
                        fontSize: computedStyle.fontSize,
                        fontFamily: computedStyle.fontFamily,
                        color: computedStyle.color
                    }
                };
            }

            async measureNetworkOverhead() {
                const startTime = performance.now();
                const networkRequests = [];
                
                if ('PerformanceObserver' in window) {
                    const entries = performance.getEntriesByType('resource');
                    entries.forEach(entry => {
                        if (entry.name.includes('remixicon') || entry.name.includes('remix')) {
                            networkRequests.push({
                                url: entry.name,
                                duration: entry.duration,
                                size: entry.transferSize || entry.decodedBodySize || 0,
                                startTime: entry.startTime
                            });
                        }
                    });
                }

                return {
                    fontLoadTime: performance.now() - startTime,
                    networkRequests: networkRequests,
                    totalFontSize: networkRequests.reduce((sum, req) => sum + req.size, 0),
                    fontStatus: document.fonts ? document.fonts.status : 'unknown'
                };
            }

            calculateStatistics(measurements) {
                const stats = {
                    renderTime: this.calculateArrayStats(measurements.renderTimes),
                    memoryUsage: {
                        used: this.calculateArrayStats(measurements.memoryUsage.map(m => m.used)),
                        total: measurements.memoryUsage.length > 0 ? measurements.memoryUsage[measurements.memoryUsage.length - 1].total : 0
                    },
                    elementMetrics: measurements.elementMetrics,
                    networkMetrics: measurements.networkMetrics,
                    sampleSize: measurements.renderTimes.length
                };
                
                return stats;
            }

            calculateArrayStats(values) {
                if (values.length === 0) return { min: 0, max: 0, average: 0, stdDev: 0, median: 0 };
                
                const sorted = [...values].sort((a, b) => a - b);
                const sum = values.reduce((a, b) => a + b, 0);
                const average = sum / values.length;
                
                const variance = values.reduce((acc, val) => acc + Math.pow(val - average, 2), 0) / values.length;
                const stdDev = Math.sqrt(variance);
                
                const median = sorted.length % 2 === 0 
                    ? (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2
                    : sorted[Math.floor(sorted.length / 2)];
                
                return {
                    min: sorted[0],
                    max: sorted[sorted.length - 1],
                    average: average,
                    stdDev: stdDev,
                    median: median
                };
            }

            async displayAggregatedResults() {
                const resultsDiv = document.getElementById('results');
                const testDuration = (performance.now() - this.startTime) / 1000;
                
                let html = `
                    <div class="bg-green-50 border border-green-200 p-3 rounded mb-4">
                        <h3 class="font-semibold text-green-800">Stress Test Complete!</h3>
                        <div class="text-sm text-green-700 mt-1">
                            Total Duration: ${testDuration.toFixed(1)}s | 
                            Total Iterations: ${this.completedIterations.toLocaleString()} | 
                            Average Speed: ${(this.completedIterations / testDuration).toFixed(1)} iterations/sec
                        </div>
                    </div>
                `;

                // Performance comparison table
                html += '<div class="bg-white rounded border overflow-hidden mb-4">';
                html += '<h3 class="font-semibold p-3 bg-gray-50 border-b">Performance Statistics</h3>';
                html += '<div class="overflow-x-auto">';
                html += '<table class="w-full text-xs">';
                html += '<thead><tr class="bg-gray-50 border-b">';
                html += '<th class="p-2 text-left">Icon Type</th>';
                html += '<th class="p-2 text-center">Avg Render (ms)</th>';
                html += '<th class="p-2 text-center">Min/Max (ms)</th>';
                html += '<th class="p-2 text-center">Std Dev</th>';
                html += '<th class="p-2 text-center">Memory Î” (KB)</th>';
                html += '<th class="p-2 text-center">Sample Size</th>';
                html += '</tr></thead><tbody>';

                // Sort results by average render time
                const sortedResults = Object.entries(this.results).sort((a, b) => 
                    a[1].renderTime.average - b[1].renderTime.average
                );

                for (const [iconType, data] of sortedResults) {
                    const isRemixIcon = iconType.includes('Font');
                    const rowClass = isRemixIcon ? 'bg-blue-25' : '';
                    
                    html += `<tr class="${rowClass} border-b">`;
                    html += `<td class="p-2 font-medium">${iconType}</td>`;
                    html += `<td class="p-2 text-center">${data.renderTime.average.toFixed(3)}</td>`;
                    html += `<td class="p-2 text-center">${data.renderTime.min.toFixed(3)} - ${data.renderTime.max.toFixed(3)}</td>`;
                    html += `<td class="p-2 text-center">${data.renderTime.stdDev.toFixed(3)}</td>`;
                    html += `<td class="p-2 text-center">${(data.memoryUsage.used.average / 1024).toFixed(1)}</td>`;
                    html += `<td class="p-2 text-center">${data.sampleSize.toLocaleString()}</td>`;
                    html += '</tr>';
                }

                html += '</tbody></table></div></div>';

                // Detailed analysis
                html += this.generateDetailedAnalysis(sortedResults, testDuration);

                resultsDiv.innerHTML = html;
            }

            generateDetailedAnalysis(sortedResults, testDuration) {
                let html = '<div class="space-y-4">';
                
                // Performance ranking
                html += '<div class="bg-white p-4 rounded border">';
                html += '<h4 class="font-semibold mb-3">Performance Ranking</h4>';
                
                sortedResults.forEach(([iconType, data], index) => {
                    const rank = index + 1;
                    const rankColor = rank === 1 ? 'text-green-600' : rank === sortedResults.length ? 'text-red-600' : 'text-gray-600';
                    html += `<div class="flex justify-between items-center py-1">`;
                    html += `<span class="${rankColor} font-medium">#${rank} ${iconType}</span>`;
                    html += `<span class="text-sm">${data.renderTime.average.toFixed(3)}ms avg</span>`;
                    html += '</div>';
                });
                html += '</div>';

                // Network overhead analysis
                const fontIcon = sortedResults.find(([name]) => name.includes('Font'));
                if (fontIcon && fontIcon[1].networkMetrics) {
                    const networkData = fontIcon[1].networkMetrics;
                    html += '<div class="bg-yellow-50 border border-yellow-200 p-4 rounded">';
                    html += '<h4 class="font-semibold text-yellow-800 mb-3">Network Overhead (Font-based Icons)</h4>';
                    html += '<div class="grid grid-cols-2 gap-4 text-sm">';
                    html += `<div><strong>Font Load Time:</strong> ${networkData.fontLoadTime.toFixed(2)}ms</div>`;
                    html += `<div><strong>Font File Size:</strong> ${this.formatMemory(networkData.totalFontSize)}</div>`;
                    html += `<div><strong>Network Requests:</strong> ${networkData.networkRequests.length}</div>`;
                    html += `<div><strong>Font Status:</strong> ${networkData.fontStatus}</div>`;
                    html += '</div></div>';
                }

                // Speed comparison
                if (sortedResults.length > 1) {
                    const fastest = sortedResults[0][1].renderTime.average;
                    const slowest = sortedResults[sortedResults.length - 1][1].renderTime.average;
                    const speedDiff = (slowest / fastest).toFixed(1);
                    
                    html += '<div class="bg-blue-50 border border-blue-200 p-4 rounded">';
                    html += '<h4 class="font-semibold text-blue-800 mb-3">Speed Analysis</h4>';
                    html += '<div class="grid grid-cols-2 gap-4 text-sm">';
                    html += `<div><strong>Speed Difference:</strong> ${speedDiff}x</div>`;
                    html += `<div><strong>Total Test Time:</strong> ${testDuration.toFixed(1)}s</div>`;
                    html += `<div><strong>Fastest Method:</strong> ${sortedResults[0][0]}</div>`;
                    html += `<div><strong>Slowest Method:</strong> ${sortedResults[sortedResults.length - 1][0]}</div>`;
                    html += '</div></div>';
                }

                html += '</div>';
                return html;
            }

            formatMemory(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            getMemoryUsage() {
                if (performance.memory) {
                    return {
                        used: performance.memory.usedJSHeapSize,
                        total: performance.memory.totalJSHeapSize,
                        limit: performance.memory.jsHeapSizeLimit
                    };
                }
                return { used: 0, total: 0, limit: 0 };
            }

            updateProgress(message, percentage) {
                if (document.getElementById('currentIcon')) {
                    document.getElementById('currentIcon').textContent = message;
                }
                if (document.getElementById('progressText')) {
                    document.getElementById('progressText').textContent = `${percentage.toFixed(1)}%`;
                }
                if (document.getElementById('progressBar')) {
                    document.getElementById('progressBar').style.width = `${percentage}%`;
                }
                if (document.getElementById('currentIteration')) {
                    document.getElementById('currentIteration').textContent = this.completedIterations.toLocaleString();
                }
                if (document.getElementById('elapsedTime')) {
                    const elapsed = (performance.now() - this.startTime) / 1000;
                    document.getElementById('elapsedTime').textContent = `${elapsed.toFixed(1)}s`;
                }
                if (document.getElementById('eta') && percentage > 0) {
                    const elapsed = (performance.now() - this.startTime) / 1000;
                    const totalEstimated = (elapsed / percentage) * 100;
                    const remaining = totalEstimated - elapsed;
                    document.getElementById('eta').textContent = `${remaining.toFixed(0)}s`;
                }
            }

            showProgress(show) {
                const progressDiv = document.getElementById('testProgress');
                const startBtn = document.getElementById('startTest');
                const stopBtn = document.getElementById('stopTest');
                
                if (show) {
                    progressDiv.classList.remove('hidden');
                    startBtn.disabled = true;
                    startBtn.textContent = 'Testing...';
                    startBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    stopBtn.classList.remove('hidden');
                } else {
                    progressDiv.classList.add('hidden');
                    startBtn.disabled = false;
                    startBtn.textContent = 'Start Stress Test';
                    startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    stopBtn.classList.add('hidden');
                }
            }

            stopTest() {
                this.shouldStop = true;
                this.isRunning = false;
                this.showProgress(false);
                
                const resultsDiv = document.getElementById('results');
                resultsDiv.innerHTML = '<div class="bg-yellow-100 border border-yellow-400 text-yellow-700 px-4 py-3 rounded">Test stopped by user.</div>';
            }

            clearResults() {
                document.getElementById('results').innerHTML = '<div class="text-gray-500">No tests run yet. Click "Start Stress Test" to begin performance analysis.</div>';
            }

            displayError(message) {
                const resultsDiv = document.getElementById('results');
                resultsDiv.innerHTML = `<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">Error: ${message}</div>`;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize the stress test manager when DOM is ready
        let stressTestManager;
        document.addEventListener('DOMContentLoaded', function() {
            stressTestManager = new StressTestManager();
        });
    </script>
</body>
</html>